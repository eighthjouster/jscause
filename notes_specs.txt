JSCause: A JS framework.  Bringing the good bits back.

Make JS work as if it was Perl or PHP:

A site/ folder.

With a hierarchy like the followng:

sites/
sites/mysite/
sites/mysite/site_configuration.json
sites/mysite/site_routes.json
sites/mysite/public/
sites/mysite/public/index.html
sites/mysite/public/index.sjs
sites/mysite/files/
sites/mysite/files/user_list.csv
sites/mysite/json/
sites/mysite/json/database.json
sites/mysite/json/custom_config.json
sites/mysite/scripts/
sites/mysite/scripts/main.sjs

public/, json/, files/, site_routes.json and scripts/ must allow hot reloading.

Each site contains:
    - A site.json file:  Site name, domain name, ssl, etc.
    - A site_routes.json (optional):  Will map files to routes, overriding whatever is on public/.
    - A public/ folder, which will contain files that can be requested directly by the browser.
    - Files with an SJS extension (for example, index.sjs) will be executed first, with its output sent to the browser.
    - A files/ folder, which will contain files that can only be accessed by server-side scripts.
    - A json/ folder, with extra configuration files:
    - database.json:  Database connection info.
    - custom_config.json: Application-specific configuration.
    - A scripts/ folder:  With server-side Javascript files.  They can only be accessed via routes, or by importing.

The ports of each site are configured in jscause.conf

public/, json/, files/, site_routes.json and scripts/ must allow hot reloading.

This is valid:
<js rt.print('WHOA 4!'); /js>

Or this:
<js
      rt.print('WHOA 4!');
/js>

- Anything outside of <js /js> will be printed out as is (regular text or HTML).
<h2><js rt.print('WHOA 4!'); /js></h2>
- To '<js' and '/js>' as literal text, prefix it with a backslash: '\<js' and '\/js>'.
- '<js /js>' are case insensitive.  These are valid: '<JS' and '/JS>'.
- If there are no tags, the whole file is considered Javascript.
- If there are no tags, but there is a <html/> tag at the top of the file, the file is considered HTML.
- If the first thing in a file is an opening tag, it can be omitted.  Likewise, the last thing in a file is a closing file, it can be omitted.
- rt.header() sets headers.  You can call them as many times as needed.
- rt.waitFor() must be used when defining callbacks.  For example:
  - Instead of:  setTimeout(() => { rt.print('Hello, world!'); }, 1000);
  - Write it as: setTimeout(rt.waitFor(() => { rt.print('Hello, world!'); }), 1000);
  - If you don't do this, then the response will be sent to the client without waiting.
  - rt.waitFor()'s can be nested.
  - rt.waitFor() will correctly pass down the arguments it receives to its callback parameter.
- rt.queryParams is an object containing the GET query parameters.
- rt.postParams is an object containing the POST form parameters.
- rt.uploadedFiles is an object containing all the uploaded files, with the keys being the form file element's name.
  - Each object could be a file or an array of files (if the form element accepts multiple files.)
  - The filename in the client is under the .name attribute.
  - The whole path, including a temp name assigned by JSCause, is under the .path attribute.
  - The developer is responsible to do something with the file during the execution of the script.  Once the script is done (and all the waitFor() callbacks completed), the files will be deleted from their temporary location.
    - So, copy the file somewhere else if you plan to save it.  Do it asynchronously if possible (in combination with waitFor().)
  - Examples:
    - rt.uploadedFiles['myFile'].name
    - rt.uploadedFiles['myFile'][0].name
  - If the canUpload server configuration value is set to false, any attempts to upload anything will immediately close the connection.  The application will try to send a 403 forbidden error, but this is not guaranteed.
    - Same thing with max file size.  If this is not desired, is advised that the users set an upper limit, and handle the actual limit error in the application. Also, warn the visitor beforehand. (You may want to provide an example here.)
  - A maxPayloadSizeBytes server config value of 0 indicated unlimited upload size.  Fewer than 0 is as if canUpload is false.
  - When POSTing, if the content-type header is set to application/json, the app will do its best to parse it.  If it fails, rt.additional.jsonParseError will be true.  If it succeeds, the json object will be available as rt.postParams.
  - If when POSTing the content-type header is set to anything other than application/json o form encoded, the payload will be available as rt.postParams.data.  If the user is sure it will be a string, they should do rt.postParams.data.toString() before processing.
  - contentType can be whatever the content-type header is set to, except for:
    - Form content: it will be formData.
    - Form content with file upload: it will be formDataWithUpload.
    - JSON: it will be jsonData.
 - We also have: rt.requestMethod ('get' or 'post').  PUT and DELETE are not supported and will return a 405 (method not allowed.)
- Never trust user input!
- print will escape symbols such as '<' and '>' so that they can be safely printed as such, so that they're not confused with being part of an HTML tag.  This is also good to avoid XSS attachs:  Use it to print user input.  If you want to print everything unescaped, use rt.unsafePrint().
- When handling uploaded files, users can use file.name directly as it has been sanitized.  If for some reason they want to access the original filename, they can do so through file.unsafeName.
- jscause.conf is almost a valid JSON object.  Almost, because it allows // comments, for documentation.
- Duplicate first-level keys in jscause.conf will cause an error.  Duplicate keys in values will be ignored, with the last value listed being the one used (just like it's done in Javascript).
- First-level keys in jscause.conf are case-insensitive.
- jscause.conf:  Global enclosing curly brackets are optional.
- Comments in jscause.conf: // are allowed.  Yes, we know comments are not valid json.  But they are allowed for documentation.
- All attributes declared in jscause.conf must be valid (known), or else the server will NOT start.  If any attribute is omitted, defaults will apply.
- No two sites can have the same name.
- No two sites can have the same rootDirectoryName/port combination (that is, they can have the same rootDirectoryName if they have different ports.)
- No two sites can have the same hostname/port combination (that is, they can have the same hostname if they have different ports.)
- A warning will be issued if two sites share the same upload directory and don't have the same host name.
- rt.runAfter() will enqueue code that will be run after all waitFor() callbacks are run (including those callbacks with implicit waitFors, like rtReadFile).  This is especially useful with the JSCause file manipulation functions.
  - You can call several rt.runAfter().  Each callback will be run one after the other (not concurrently.)
  - rt.waitFor() can be used inside rt.runAfter() callbacks.  If they are used, any enqueued runAfter callbacks will again wait until said waitFor callbacks are run.
- rt.readFile(path) allows to read a file from path.  It behaves in a promise-like way.
  - Chain it with .rtThen() with a callback with the response as a parameter:
     rt.readFile(path).rtThen((response) => { rt.print(response); });
       - No need to wrap the callback with a waitFor().
  - Chain it with .rtCatch() with a callback with the error as a parameter:
     rt.readFile(path)
     .rtThen((response) => { rt.print(response); });
     .rtCatch((err) => { rt.print(err.code); });
       - Again, no need to wrap the callback with a waitFor().
  - Relies on readFile.  So, whatever limitations readFile has, this one has as well (e.g., handling of big files, etc.)
  - An absolute paths can be provided.  If a relative path is provided instead, it will be relative to the site's root directory (rootDirectoryName).
  - rt.readFile()'s can be nested.
  - rtThen() and rtCatch() can be omitted (but if omitted, the server will issue a runtime error.)
- rt.copyFile(source, destination, overwrite) allows to copy a file from source to destination.  It behaves in a promise-like way, just like rt.readFile().
  - The third parameter is optional, and true if omitted.  If true, the destination will be overwritten if it exists.  If false, an EEXIST error will be thrown (catchable with rtCatch, err.code).
  - Absolute paths can be provided.  If relative paths are provided instead, they will be relative to the site's root directory (rootDirectoryName).
  - rtThen() and rtCatch() can be omitted (but if omitted, the server will issue a runtime error.)
- Tip: Common error: If you receive an unexpected token error referring to a part of the file that was supposed to be treated as HTML, check if the closing /js> previous to the line with the error was put in a line with a comment in it.  Example:  // This whole line is a comment /js>
- Tip: Moving uploaded files is quicker than copying them to their final destination.
- Other file functions:
  - rt.moveFile(source, destination, overwrite).
    - Notice that if overwrite is false and a file exists, the error thrown is not native, but it tries to mimmick what copyFile does as much as possible.  The 'errno' attribute won't be available.  This is because POSIX rename will always overwrite.  We had to check for file existence first.
