JSFramework: working title.

Make JS work as if it was Perl or PHP:

A site/ folder.

With a hierarchy like the followng:

sites/
sites/mysite/
sites/mysite/site_configuration.json
sites/mysite/site_routes.json
sites/mysite/public/
sites/mysite/public/index.html
sites/mysite/public/index.sjs
sites/mysite/files/
sites/mysite/files/user_list.csv
sites/mysite/json/
sites/mysite/json/database.json
sites/mysite/json/custom_config.json
sites/mysite/scripts/
sites/mysite/scripts/main.sjs

public/, json/, files/, site_routes.json and scripts/ must allow hot reloading.

Each site contains:
    - A site_configuration.json file:  Site name, listening port, domain name, ssl, etc.
    - A site_routes.json (optional):  Will map files to routes, overriding whatever is on public/.
    - A public/ folder, which will contain files that can be requested directly by the browser.
    - Files with an SJS extension (for example, index.sjs) will be executed first, with its output sent to the browser.
    - A files/ folder, which will contain files that can only be accessed by server-side scripts.
    - A json/ folder, with extra configuration files:
    - database.json:  Database connection info.
    - custom_config.json: Application-specific configuration.
    - A scripts/ folder:  With server-side Javascript files.  They can only be accessed via routes, or by importing.

public/, json/, files/, site_routes.json and scripts/ must allow hot reloading.

This is valid:
<js rt.print('WHOA 4!'); /js>

Or this:
<js
      rt.print('WHOA 4!');
/js>

- Anything outside of <js /js> will be printed out as is (regular text or HTML).
<h2><js rt.print('WHOA 4!'); /js></h2>
- To '<js' and '/js>' as literal text, prefix it with a backslash: '\<js' and '\/js>'.
- '<js /js>' are case insensitive.  These are valid: '<JS' and '/JS>'.
- If there are no tags, the whole file is considered Javascript.
- If there are no tags, but there is a <html/> tag at the top of the file, the file is considered HTML.
- If the first thing in a file is an opening tag, it can be omitted.  Likewise, the last thing in a file is a closing file, it can be omitted.
- rt.header() sets headers.  You can call them as many times as needed.
- rt.waitFor() must be used when defining callbacks.  For example:
  - Instead of:  setTimeout(() => { rt.print('Hello, world!'); }, 1000);
  - Write it as: setTimeout(rt.waitFor(() => { rt.print('Hello, world!'); }), 1000);
  - If you don't do this, then the response will be sent to the client without waiting.
  - rt.waitFor()'s can be nested.
- rt.queryParams is an object containing the GET query parameters.
- rt.postParams is an object containing the POST form parameters.
- rt.uploadedFiles is an object containing all the uploaded files, with the keys being the form file element's name.
  - Each object could be a file or an array of files (if the form element accepts multiple files.)
  - The filename in the client is under the .name attribute.
  - The whole path, including a temp name assigned by JSCause, is under the .path attribute.
  - The developer is responsible to do something with the file during the execution of the script.  Once the script is done (and all the waitFor() callbacks completed), the files will be deleted from their temporary location.
    - So, copy the file somewhere else if you plan to save it.  Do it asynchronously if possible (in combination with waitFor().)
  - Examples:
    - rt.uploadedFiles['myFile'].name
    - rt.uploadedFiles['myFile'][0].name
  - If the canUpload server configuration value is set to false, any attempts to upload anything will immediately close the connection.  The application will try to send a 403 forbidden error, but this is not guaranteed.
    - Same thing with max file size.  If this is not desired, is advised that the users set an upper limit, and handle the actual limit error in the application. Also, warn the visitor beforehand. (You may want to provide an example here.)
  - A maxPayloadSizeBytes server config value of 0 indicated unlimited upload size.  Fewer than 0 is as if canUpload is false.
  - When POSTing, if the content-type header is set to application/json, the app will do its best to parse it.  If it fails, rt.additional.jsonParseError will be true.  If it succeeds, the json object will be available as rt.postParams.
  - If when POSTing the content-type header is set to anything other than application/json o form encoded, the payload will be available as rt.postParams.data.  If the user is sure it will be a string, they should do rt.postParams.data.toString() before processing.
  - contentType can be whatever the content-type header is set to, except for:
    - Form content: it will be formData.
    - Form content with file upload: it will be formDataWithUpload.
    - JSON: it will be jsonData.
 - We also have: rt.requestMethod ('get' or 'post').  PUT and DELETE are not supported and will return a 405 (method not allowed.)
- Never trust user input!
- printSafely will escape symbols such as '<' and '>' so that they can be safely printed as such, so that they're not confused with being part of an HTML tag.  This is also good to avoid XSS attachs:  Use it to print user input.
- When handling uploaded files, users can use file.name directly as it has been sanitized.  If for some reason they want to access the original filename, they can do so through file.unsafeName.
- jscause.conf is almost a valid JSON object.  Almost, because it allows // comments, for documentation.
- Duplicate first-level keys in jscause.conf will cause an error.  Duplicate keys in values will be ignored, with the last value listed being the one used (just like it's done in Javascript).
