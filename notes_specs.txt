JSCause: A JS framework.  Bringing the good bits back.

Make JS work as if it was Perl or PHP:

A site/ folder.

With a hierarchy like the followng:

sites/
sites/mysite/
sites/mysite/configuration/custom.json
sites/mysite/configuration/database.json
sites/mysite/configuration/site.json
sites/mysite/website/
sites/mysite/website/index.html
sites/mysite/website/index.jscp
sites/mysite/workbench/

website/ and configuration/ must allow hot reloading.

Each site contains:
    - A configuration/site.json file:  Site name, domain name, ssl, etc.
    - A website/ folder, which will contain files that can be requested directly by the browser.
      - Files with a JSCP extension (for example, index.jscp) will be executed first, with its output sent to the browser.  They can only live inside website/
      - Module files with a JSCM extension (for example, module.jscm) can be called from JSCP files using 'require()' (perhaps, 'import' too? Still relevant?). They can only live inside website/
      - The file name is case-sensitive (if the file system allows it).  A file will be considered JSCP only if its extension is lower case (that is, .jscp is valid, but .JSCP is not.)  Same with JSCM.
    - The configuration/ folder may have extra configuration files:
      - database.json:  Database connection info.
      - custom.json: Application-specific configuration.

The ports of each site are configured in jscause.conf

This is valid:
<js rt.print('WHOA 4!'); /js>

Or this:
<js
      rt.print('WHOA 4!');
/js>

- Anything outside of <js /js> will be printed out as is (regular text or HTML).
<h2><js rt.print('WHOA 4!'); /js></h2>
- To output '<js' and '/js>' as literal text, prefix it with a backslash: '\<js' and '\/js>'.
- '<js /js>' are case insensitive.  These are valid: '<JS' and '/JS>'.
- If there are no tags, the whole file is considered Javascript.
- If there are no tags, but there is an <html/> tag at the top of the file, the file is considered HTML.
- If the first line in a file is an opening tag, it can be omitted.  Likewise, the last line in a file is a closing file, it can be omitted.
- rt.header() sets headers.  You can call them as many times as needed.
- rt.waitFor() must be used when defining callbacks.  For example:
  - Instead of:  setTimeout(() => { rt.print('Hello, world!'); }, 1000);
  - Write it as: setTimeout(rt.waitFor(() => { rt.print('Hello, world!'); }), 1000);
  - If you don't do this, then the response will be sent to the client without waiting.
  - rt.waitFor()'s can be nested.
  - rt.waitFor() will correctly pass down the arguments it receives to its callback parameter.
  - If a runtime exception happens while a callback is still pending, JSCause will wait until the blocking call is happening.  When it comes back, it won't execute the callback.
- rt.getParams is an object containing the GET query parameters.
- rt.postParams is an object containing the POST form parameters.
- rt.uploadedFiles is an object containing all the uploaded files, with the keys being the form file element's name.
  - Each object could be a file or an array of files (if the form element accepts multiple files.)
  - The filename in the client is under the .name attribute.
  - The whole path, including a temp name assigned by JSCause, is under the .path attribute.
  - The developer is responsible to do something with the file during the execution of the script.  Once the script is done (and all the waitFor() callbacks completed), the files will be deleted from their temporary location.
    - The temporary location is specified by tempWorkDirectory.  The default is './workbench'.  A relative path must be provided, which will be relative to the site's directory.  An absolute path CANNOT be specified.  It must be valid if 'canUpload' is true.
    - So, copy the file somewhere else if you plan to save it.  Do it asynchronously if possible (in combination with waitFor().)
  - Examples:
    - rt.uploadedFiles['myFile'].name
    - rt.uploadedFiles['myFile'][0].name
  - If the canUpload server configuration value is set to false, any attempts to upload anything will immediately close the connection.  The application will try to send a 403 forbidden error, but this is not guaranteed.
    - Same thing with max file size.  If this is not desired, it is advised that the users set an upper limit, and handle the actual limit error in the application. Also, warn the visitor beforehand. (You may want to provide an example here.)
  - A maxPayloadSizeBytes server config value of 0 indicates unlimited upload size.  Less than 0 is as if canUpload is false.  Use the 0 value with caution.
  - When POSTing, if the content-type header is set to application/json, the app will do its best to parse it.  If it fails, rt.additional.jsonParseError will be true.  If it succeeds, the json object will be available as rt.postParams.
  - If when POSTing the content-type header is set to anything other than application/json o form encoded, the payload will be available as rt.postParams.data.  If the user is sure it will be a string, they should do rt.postParams.data.toString() before processing.
  - contentType can be whatever the content-type header is set to, except for:
    - Form content: it will be formData.
    - Form content with file upload: it will be formDataWithUpload.
    - JSON: it will be jsonData.
 - We also have: rt.requestMethod ('get' or 'post').  PUT and DELETE are not supported and will return a 405 (method not allowed.)
- Never trust user input!
- print will escape symbols such as '<' and '>' so that they can be safely printed as such, so that they're not confused with being part of an HTML tag.  This is also good to avoid XSS attachs:  Use it to print user input.  If you want to print everything unescaped, use rt.unsafePrint().
- When handling uploaded files, users can use file.name directly as it has been sanitized.  If for some reason they want to access the original filename, they can do so through file.unsafeName.
- jscause.conf is almost a valid JSON object.  Almost, because it allows // comments, for documentation.
- Duplicate first-level keys in jscause.conf will cause an error.  Duplicate keys in values will be ignored, with the last value listed being the one used (just like it's done in Javascript).
- First-level keys in jscause.conf are case-insensitive.
- jscause.conf:  Global enclosing curly brackets are optional.
- Comments in jscause.conf: // are allowed.  Yes, we know comments are not valid json.  But they are allowed for documentation.
- All attributes declared in jscause.conf must be valid (known), or else the server will NOT start.  If any attribute is omitted, defaults will apply.
- No two sites can have the same name.
- No two sites can have the same rootDirectoryName/port combination (that is, they can have the same rootDirectoryName if they have different ports.)
- No two sites can have the same hostname/port combination (that is, they can have the same hostname if they have different ports.)
- A warning will be issued if two sites share the same upload directory and don't have the same host name.
- rt.runAfter() will enqueue code that will be run after all waitFor() callbacks are run (including those callbacks with implicit waitFors, like rtReadFile).  This is especially useful with the JSCause file manipulation functions.
  - You can call several rt.runAfter().  Each callback will be run one after the other (not concurrently.)
  - rt.waitFor() can be used inside rt.runAfter() callbacks.  If they are used, any enqueued runAfter callbacks will again wait until said waitFor callbacks are run.
- rt.readFile(path) allows to read a file from path.  It behaves in a promise-like way.
  - Chain it with .rtOnSuccess() with a callback with the response as a parameter:
     rt.readFile(path).rtOnSuccess((response) => { rt.print(response); });
       - No need to wrap the callback with a waitFor().
  - Chain it with .rtOnError() with a callback with the error as a parameter:
     rt.readFile(path)
     .rtOnSuccess((response) => { rt.print(response); });
     .rtOnError((err) => { rt.print(err.code); });
       - Again, no need to wrap the callback with a waitFor().
  - Relies on readFile.  So, whatever limitations readFile has, this one has as well (e.g., handling of big files, etc.)
  - Absolute paths can be provided.  If a relative path is provided instead, it will be relative to the site's root directory (rootDirectoryName).
    - Avoid reading or manipulating the path specified by tempWorkDirectory directly.  This is used by the framework.
  - rt.readFile()'s can be nested.
  - rtOnSuccess() and rtOnError() can be omitted (but if omitted, and an error occurs, the server will issue a runtime error.)
- rt.copyFile(source, destination, overwrite) allows to copy a file from source to destination.  It behaves in a promise-like way, just like rt.readFile().
  - The third parameter is optional, and true if omitted.  If true, the destination will be overwritten if it exists.  If false, an EEXIST error will be thrown (catchable with rtOnError, err.code).
  - Absolute paths can be provided.  If relative paths are provided instead, they will be relative to the site's root directory (rootDirectoryName).
  - rtOnSuccess() and rtOnError() can omit their parameter (that is, their callback.)  This is not advisable from an application development standpoint, but it's allowed.
  - rtOnError() can be omitted, but if an error occurs, the server will issue a runtime error.
- rt.module(moduleName): Syntactic sugar for: require('./moduleName.jscm').
  - It could be either: rt.module('moduleName') or rt.module('moduleName.jscm')
  - Path is relative to the website's directory (e.g. 'moduleName' => 'mySite/website/moduleName.jscm').
  - Absolute paths are not permitted.

- Tip: Common error: If you receive an unexpected token error referring to a part of the file that was supposed to be treated as HTML, check if the closing /js> previous to the line with the error was put in a line with a comment in it.  Example:  // This whole line is a comment /js>
- Tip: Moving uploaded files is quicker than copying them to their final destination.
- Other file functions:
  - rt.moveFile(source, destination, overwrite).
    - Notice that if overwrite is false and a file exists, the error thrown is not native, but it tries to mimmick what copyFile does as much as possible.  The 'errno' attribute won't be available.  This is because POSIX rename will always overwrite.  We had to check for file existence first.
  - rt.deleteFile(path).
  - rt.fileExists(path).  rtOnSuccess is called if file exists.  rtOnError otherwise.  It is advised that the error be examined.  Typically, err.code should be 'ENOENT'.
  - rt.getCurrentPath() will yield the request's path without the resource (file name) portion.  So, if the request is /some/directory/hello.jscp, rt.getCurrentPath() will return '/some/directory'.
- Notice that if there is an error inside .rtOnSuccess(), the code will not jump to .rtOnError(), as these only deal with the original corresponding operation.  JSCause will emit a typical error (you can trap it with try() catch{} though.)
- Filesystem - URL mapping:
  - Folders (directories) are allowed.
  - Folders with names with extensions are allowed.
  - If a folder is specified with no file/resource name (e.g. /myFolder/), JSCause will assume /myFolder/index.jscp.  If /myFolder/index.jscp doesn't exist, it will throw a 404 error.
  - If there is a file with the same name as a folder + the jscp extension (for example, file name hello.jscp and folder name hello), the file takes precedence for the /filename url (example: /hello.)  To specify the folder, add a '/', as in /hello/, or use /hello/index, or /hello/index.jscp
  - Files with .jscp extensions can be referred to without said extension.  For example, hello.jscp can be referred to both as /hello and /hello.jscp (but not /hello/ or /hello.jscp/, which will throw a 404 error.)  The file /myFolder/hello.jscp can be referred to as /myFolder/hello
  - '.' and '..' are not allowed.
  - Files and folders starting with '.' (e.g. '.myFile.jscp') will be considered hidden, and thus, ignored by the JSCause server.  It's as if they're not there, and thus they won't be served.
  - A file literally named '.jscp', while technically hidden, will still be parsed during server init.  So it must be a valid JSCP file.
- The per-site httpPoweredByHeader config value can show or hide the 'X-Powered-By: jscause' HTTP response header.  Assign 'include' to show, 'exclude' to hide.

HTTPS:
======
- Set "enableHTTPS" to true in a site configuration entry in jscause.conf.
- Set the cert and key files on each site.json
- Be _very_ clear that the certs provided should NOT be used in production.
  - As the matter of fact, I wonder if there is a way to detect them when the server starts and emit a warning if they are attempted to be used (by comparing them with a hash?) And only if https is attempted to be used.
  - Direct users to nodejs documentation on how to generate their own certs.
- Disclaimer: very basic https implementation.  Something more robust/more exhaustive might be implemented in a future version.
- httpsCertFile and httpsKeyFile are required if enableHTTPS is true.  Otherwise, they can be omited (BUT if included, their values must be valid; e.g., not empty string).
- If two servers share the same HTTPS port, only the httpsCertFile and httpsKeyFile of the first server listed in jscause.conf will be taken into account to configure the SSL connection.
  - FAQ: Why aren't httpsCertFile and/or httpsKeyFile reported as invalid when they are invalid?
    - The site is not HTTPS.
    - The site is HTTPS but is sharing the port with another HTTPS site which has valid httpsCertFile and httpsKeyFile.
- Each HTTPS site should use its own port.  Warnings will be emitted if two HTTPS sites share the same port, or if an HTTP site shares the port with an already configured HTTPS site.  If an HTTPS site tries to share the port of an already configured HTTP site, an error will be emitted instead for security purposes.

 - FAQ: site.json accepts a hostName that could already be being used in another site's site.json.  Is this a bug?
 - This is fine as long as both sites use different ports.


Custom errors 4xx and 5xx:
=========================
 - Custom errors, if available, will be delivered only during a typical interaction in which a resource is not really available, or an error on a JSCP script.  In other cases, generic 4xx or 5xx will be delivered to the browser.  For instance:
   - When attempting to use an unrecognized HTTP method.
   - When file uploads are not allowed, or the payload maximum is exceeded.
   - When the site (domain name) is not recognized.
   - When either a form upload or json body upload parsing fails.
   - When delivering a non-cached static file produces an error (e.g., file was available during parsing, but became unavailable later.)
   - Possibly others.

- error4xx.jscp/html and error5xx.jscp/html.  html prevails over jscp.
- Only the ones on the site's root will be taken into account.
- Referring to them directly (e.g. explicit '/error5xx.html' request from the browser) will throw a default error 404.
- If you name a directory error400/500.jscp/html, it will throw a 404 error unless a slash is added.  This is by design.
- Note:  If either error4xx.jscp or error5xx.jscp have a compile/runtime error, a generic 5xx will be delivered to the browser.  So, if an error 400 happens, and the error4xx.jscp has an error, the browser will indicate error 500.

Symlinks:
=========
 - They work the same way they work on the host operating system.

File and directory limits:
==========================

- A maximum of 2048 subdirectories or files are allowed in a single directory; including those resolved by following symbolic links.
- A maximum of 4096 directories/subdirectories are allowed overall in a single application.

How files are mapped to url routes:
===================================

1. If the url is '/', '/index.jscp' will be assumed (see #5.)
2. If the url is '/name.jscp' (or '/directory/name.jscp'), JSCause will check for the file.  If it exists, and jscpExtensionRequired is either 'optional' or 'always', it will run it (see #5.)  If it doesn't, or if the url ends in '/' (e.g. '/directory/name/' or, if jscpExtensionRequired is either 'optional' or 'always', '/directory/name.jscp/'), it will assume it's a directory (see #4.)
3. If the url is '/name' (or '/directory/name'), and if jscpExtensionRequired is either 'never' or 'optional', JSCause will check for the file '/name.jscp' (or '/directory/name.jscp').  If it exists, it will run it (see #5.)  If the file name does not exist, or if the url ends in '/', it will assume it's a directory (see #4.)
4. If the url refers to a directory (e.g. '/name' or '/name/'), check for '/name/index.jscp'.  This check happens regardless of the value of jscpExtensionRequired.
5. If the url is '/name.jscp' (or '/directory/name.jscp'), and again, if jscpExtensionRequired is either 'optional' or 'always', then JSCause will run the contents and serve its output.
6. If the url is '/name.extension', with the extension being neither jscp nor jscm (or not present), JSCause will check for the file.  If it exists, JSCause assumes it is static, and it will serve the contents of it.
6. If the extension is jscm, serve a 404.
7. If none of the above applies, serve a 404.

File names:
===========

- File and directory names are assumed UTF8-encoded.  If the file system allows spaces in names, JSCause will respect this.
- If the site config directive "jscpExtensionRequired" has the following value:
  - "never": Then routes associated to jscp files must NEVER be specified with the jscp extension (e.g.: http://www.example.com/executable instead of http://www.example.com/executable.jscp).  Otherwise the server will throw a 404 error.  Notice that /index (with no extension), be it the root directory or any other directory, will also give a 404 error here.  Notice that directory names ending in '.jscp' will throw a 404 if addressed on their own (e.g. http://www.example.com/directory.jscp)
  - "always": Then routes associated to jscp files must ALWAYS be specified with the jscp extension (e.g.: http://www.example.com/executable.jscp instead of http://www.example.com/executable).  Otherwise the server will throw a 404 error.  Naturally, /index (with no extension), be it the root directory or any other directory, will also give a 404 error here.
  - "optional": Then routes associated to jscp files may omit the file extension (e.g.: both http://www.example.com/executable.jscp and http://www.example.com/executable refer to the same route).  Naturally, /index (with no extension), be it the root directory or any other directory, is also allowed.

Mime types:
===========

JSCause can handle a set of mime types according to the url resource extension (e.g. 'image.png') [TODO: List them here.  See: MIME_TYPES].
An unrecognized mime type will be treated as 'application/octet-stream'.  In these cases, the browser may attempt to download instead of display the resource.
Add extra mime types to the list of recognized ones (or replace their values), with the "mimeTypes" configuration directive:
  "mimeTypes": {
    "include": {
      "png": "image/png",
      "some_other_type": "some_other_value"
    }
  }
If you specify an empty string as a value, it will be assumed octect-stream (a warning will be shown in the server console during startup.)

If you want a mime type to be handled as 'application/octet-stream' (e.g. for downloading), put it in the 'exclude' list (note that 'exclude' is an array, as opposed to 'include', which is an associative array):
  "mimeTypes": {
    "exclude": [
      "jpg",
      "some_other_type"
    ]
  }

Include and exclude can be used at the same time:
  "mimeTypes": {
    "include": {
      "png": "image/png",
      "some_other_type": "some_other_value"
    },
    "exclude": [
      "jpg",
      "some_other_type"
    ]
  }

If the same mime type is added to both lists, the lattermost list will prevail (e.g. if 'exclude' is defined after 'include', then the mime-type will be excluded.)
JSCause will not guarantee which value is assigned to a mime type listed more than once in the 'include' section.

Static files:
=============
- Files up to MAX_CACHEABLE_FILE_SIZE_BYTES (512 * 1024 = 512KBytes) will be cached.  Files larger than that will be read from the file system and served upon request.
- Up to MAX_CACHED_FILES_PER_SITE (256) files will be cached in memory.  The rest will be read from the file system and served upon request.
- While JSCause can handle static files, it is advised to serve them by other more efficient means, e.g. with nginx or a CDN.
- Advise the reader to put all the .js files that will be served to the client in a single directory, to keep things tight and secure.  JS files that should be executed on the server should reside outside of the /website directory.

Cookies:
========

rt.getCookie(name, options)
rt.setCookie(name, value, options) - returns true if successful.
rt.deleteCookie(name) - returns true if successful.
name must be a string.  Otherwise getCookie() will return an empty string, and setCookie() and deleteCookie() will return false.
domain, path and value parameters should be a string.  Numbers can be used, but they will be converted to strings.  Anything else will be converted to its .toString() equivalent.  For instance, objects will be assumed "[object Object]", arrays will be converted to a string with its values comma-separated.
name is always URI-encoded before the cookie is stored.
options can be:
 - expires: expiration date as a Date object. Optional (if so, the cookie will last as long as the current browser session lasts).  If a value is passed, it must be a date object; otherwise a runtime exception will be thrown.
 - maxAge: expiration in milliseconds from date of creation. Optional.  Must be number or it will be ignored.  If both 'expires' and 'maxAge' are provided, 'expires' is used.
 - secure: Optional. Boolean.  Accepts any value which is then converted to boolean.  Will throw exception if set to true in a non-HTTPS request.
 - httpOnly: Optional. Boolean or equivalent truthy/falsy value. True by default.
 - path: Optional. String. '/' by default.  Use rt.getCurrentPath() if you want to set the cookie for the request (current) path.  Use 'null' if you want to omit setting up a path completely (this could change in the future, though.)
 - domain: String. No default, per the cookies specs.
 - sameSite: Optional. String. 'lax' or 'strict'.  Any other value will throw an exception.
 - You could always wrap rt.setCookie() in a try/catch block if you don't want it to trigger error 500.  But do always check for exceptions!
 - For setCookie:  encodeURIValue: Optional.  Boolean.  True by default.  When true, the cookie value is URI-encoded before being stored.
 - For getCookie:  decodeURIValue: Optional.  Boolean.  True by default.  When true, the cookie value is URI-decoded before being returned.

Redirection:
============

- rt.redirectTo(url, [delayInSeconds])
- The url should be a string.  Numbers will be interpreted as strings, and any other type will be converted to its .toString() equivalent.  undefined will be assumed as an empty string (notice that this could potentially create a infinite redirection loop!)
- The redirection will happen (be scheduled to run) when all the program gets executed (and all pending callbacks, e.g. from setTimeout and file operations, are run.)  If you don't like this, organize your code to avoid it.
- An optional delayInSeconds parameter can be provided.  In that case, the redirect will be delayed by that amount of seconds (counting from the time it is scheduled to run - see previous point.)  This value must be a number, otherwise it will be ignored.
  - Notice that JSCause typically sets the Location header to do the redirect.  If delayInSeconds is provided and is valid, the 'Refresh' header will be used instead.  This is not a standard header, so not all browsers support it (most modern ones do, though.)
- If more than one redirectTo() calls are made, only the last one will be taken into account.
- rt.resetRedirectTo() (no parameters.)
  - It will cancel any scheduled redirections.
    - No effect if no redirects are scheduled to happen.

In regards of 'this':
=====================
'this' is an empty object ({}) during the execution of the script.  Its value will not carry over the next time the script is called with a new request.
 - If you use setInterval(), you will see that the 'this' can be modified and its modified content will be available next time the callback is run.  This is normal behavior.  That setInterval() is occurring inside the execution environment of the request that started it.
 - When a function is defined inside a script (or imported with rt.module()), the 'this' inside it will be the system's.  This behavior could change in a future version; perhaps not completely, but there might be some optional configuration directive to make it an empty object.
 
Testing related:
================

If you use methods that require waiting to complete via a callback, use this.waitForDoneSignal() as the callback.  If you want to provide a custom callback, pass it as a parameter of waitForDoneSignal().  For example:
      testServer.close(this.waitForDoneSignal(() =>
      {
        console.log('This is called when close() completes.');
      }));

For promises that assume that the test will end when a .then() or a .catch() is invoked, set this.waitForContinueTestingCall to true in the promise declaration, and call this.continueTesting() at the very end of the then() and catch() blocks.  Remember:  This will end the current test, and move on to the next one, no waiting at all.

waitForDoneSignal() can only be used once in a single phase function.  Trying to call it more than once will throw a critical error and abort testing.
 - A workaround would be using it at last nested callback, or put all the callbacks inside a Promise.all(), or similar approach.
 - You could also do something like:
   const triggerDoneSignal = this.waitForDoneSignal();
   then call triggerDoneSignal() anywhere you want.
     - This will immediately move on to the next test, though (no waiting for pending callbacks).  So be judicious.  For example:  if the test battery is at a later phase, and an old triggerDoneSignal() from a previous phase is triggered, well, it will be as if it was invoked in the current test and the battery will unexpectedly move on to the next phase.
     Therefore, this trick is recommended to be used on tests involving onTestBeforeStart()/onReadyForRequests()/onTestEnd() only.

Some on() calls could be called more than once if more than one server is started during the test.  Using onServerStartedOrError() and this.numberOfServersInvokedSofar to keep track of server invocations can help handle scenarios, well, post-server invocations.

When testing server requests:
 - Use onReadyForRequests() to start making requests to the server.
   - onReadyForRequests() is used to test requests to the server.  Invoke http.request() and/or https.request() here.
   - You MUST set this.isRequestsTest to true inside onTestBeforeStart().
   - When this call is used, jscTest will automatically do this:
      - this.doneRequestsTesting() will be available for invocation.  It *MUST* be invoked at some point during the phase, or else we will never advance to the next phase and the test battery will remain stuck waiting indefinitely.
        - Recommended places: res.on('end', ...) and req.on('error', ...).
        - Note: this.doneRequestsTesting has the result of invoking this.waitForDoneSignal().  So, it's sort of syntactic sugar.
  - It is highly recommended that no other phases other than onTestBeforeStart() and onTestEnd() are used when onReadyForRequests() is present due to the nature of doneRequestsTesting() (see the documentation on waitForDoneSignal(), especifically the triggerDoneSignal() limitation workaround trick.)
 - When doneRequestsTesting() is called, then onAllRequestsEnded() is invoked.
   - So, onAllRequestsEnded is invoked when no more requests and responses are pending from the server.
 - Use onAllRequestsEnded() to terminate the application as follows:
   - this.terminateApplication({ onComplete: this.waitForDoneSignal() });
     - waitForDoneSignal() is crucial here, otherwise the server will still be open when the next test starts.  This could lead to port conflicts and similar errors that could cause later tests to fail.



Known issues:
=============

- Does not support resuming of interrupted large file downloads.  For a future version.

- For now, every file is assumed UTF-8.

- When invoking a function defined inside a JSCP script (or when using rt.module()), 'this' inside the module will be the system's.  In a future version, a configurable directive may force it to an empty object.  But we'll see.

- Firefox 61.0.2 on MacOS High Sierra has issues when reloading a page that renders after an upload.  If a user uploads a file, then re-loads the page (triggering a browser re-upload confirmation page), Firefox will reset the connection.  Newer versions do not exhibit this behavior.  Chrome does not exhibit this behavior either.

- Modules do not have direct access to rt functions.  A workaround would be to pass in the rt object when invoking the module:
   - Inside the module: module.exports = function(rt) { use rt here... }
   - Script invoking the module: const myModule = rt.module('examplemodule')(rt);

