Pending:
========

Ugh, now test_009_003_siteConfInvalidHTTPSKeyFilePt2 is showing the "The server did not terminate by the time all testing was completed" message.

Fixed.  Now, use 0 instead of 125 and see if that works.

Why is the test_015_004_UserFilesReading_MaxDirs_nothresholdPassed test not passing?
 - Once you fix it, check the rest in that file that are marked with __RP.

If:
{ isPostTerminationCallback: true }), 0);//__RP should this be 0?
should be really 0, then MAX_NUMBER_OF_JSCLOGTERMINATE_RETRIES should be way more than 185.

Do we still need isPostTerminationCallback?
 - And pendingTerminationCallbacks?

Also, when the server errors out, jsclogterminate() is invoked.
  - This is problematic since jsclogterminate() is invoked during testing thanks to terminateapplication(), I think.  If the waitForLogsProcessingBeforeTerminate mitigates race conditions, you may want to put this in the future fixes section, alongside a way to reproduce, or things to look out for.

If you change the 125 number, change the 125 comment (how to make it future-proof? Constant?)

When tests testBattery_014 and testBattery_015 are the only ones uncommented, tests fail randomly.  What gives?

Document onAllRequestsEnded().  Put it on testBattery_000 and testBatteryUtils.
 - And the fact that terminateApplication() can have an onComplete callback.

Document:
For the dev docs:
IMPORTANT: Every use of jscThen() requires using jscCatch(), even if the latter is empty!!
 - This is because they both decrease the pending callback counts by two (since only one will actually be executed; so the other one needs to be 'discarded'.)

 - I think it's better if we start incorporating these in the testing suite.
   - Starting with step 1 below.
     - Ok.  Laid out a lot of ground work.  Please proceed with test building.

 - I'm documenting so we can one day automate it:
*1. One single site, one single, empty index.jscp file.
  Expected: Output: Blank page.  0 bytes.

*2. index.jscp just with one line:
console.log(1);
  Expected: Server console prints 1 with each request.

*3. index.jscp with just one line:
rt.print(1);
  Expected: Page showing '1'.

*4. index.jscp with just one line:
p
  Expected: Error 500.

*5. index.jscp with just one line:
/js>p
  Expected: Page showing 'p'.

*6. index.jscp:
console.log('\<js');
console.log('\/js>');
rt.print('\<js');
rt.print('\/js>');
  Expected:
    - Page showing '<js/js>'.
    - Console output showing:
<js
/js>

*7. index.jscp:
<js rt.print('1'); /js><js rt.print('2'); /js>
<js rt.print('3'); /js>
<js rt.print('4'); /js>
<js rt.print('5');
/js>
<js
rt.print('6'); /js>
<js
rt.print('7');
/js>

<js
rt.print('8');/js><js

rt.print('9');

/js>
abc<js rt.print('d'); /js>

efg

<js rt.print('h'); /js>
<js rt.print('i');


/js><js


rt.print('j');


/js>
<js               rt.print('k');rt.print('l');                   /js>
<JS rt.print('m'); /JS>
  Expected:
    - Page showing '12 3 4 5 6 7 89 abcd efg h ij kl m '
    - Page source showing:
12 
 3 
 4 
 5 
 6 
 7 
 89 
 abcd 
 efg 
 h 
 ij 
 kl 
 m 
  
*8. index.jscp:
<html/>Hello

  Expected:
    - Page showing 'Hello'.

*9. index.jscp:
<html/>
Hello

  Expected:
    - Page showing 'Hello'.

*10. index.jscp:
<html/>Hello
<js console.log(1);

  Expected:
    - Page showing 'Hello'.
    - Console output showing:
1

10. index.jscp:
<html/>Hello
<js console.log(1);

  Expected:
    - Page showing 'Hello'.
    - Console output showing:
1


AT THIS POINT: BACK UP.

Before continuing:
 - Run all tests.  All good?
 - Document onReadyForRequests().  Put it in the example and in the battery utils (look for: // TO-DO: EXPLAIN HERE.)
   - Used to test requests to the server.  Invoke http.request() and/or https.request() here.
   - You MUST set this.isRequestsTest to true inside onTestBeforeStart().
   - When this call is used, jscTest will automatically do this:
      - this.pendingCallbackTrackingEnabled = false; // Required so signalTestEnd() doesn't get invoked endlessly due to req.end() triggering a bunch of jscCallback calls.
      - this.doneRequestsTesting() will be available for invocation.  It *MUST* be invoked at some point during the phase, or else we will never advance to the next phase and the test battery will remain stuck waiting indefinitely.
        - Recommended places: res.on('end', ...) and req.on('error', ...).
        - Note: this.doneRequestsTesting has the result of invoking this.waitForDoneSignal().  So, it's sort of syntactic sugar.
  - It is highly recommended that no other phases other than onTestBeforeStart() and onTestEnd() are used when onReadyForRequests() is present due to the nature of doneRequestsTesting() (see the documentation on waitForDoneSignal(), especifically the triggerDoneSignal() limitation workaround trick.)

Pending manual testing:
 - GET parameters.
 - POST requests.
   - POST parameters.
     - As forms.
     - As JSON.
     - As some other format (it should throw error 500, I think?)
 - Uploads:
  - Two sites, two separate temp upload directories, right?
 - At this point, release the alpha.

 - Handling PUT/DELETE requests (which I think aren't supported.)
 - Stalling the page with a setTimeout.
 - Callbacks and rt.waitFor(), rt.Then(), rt.Catch() (or whatever their right syntax are.)
   - Nesting.
 - rt.* methods.
 - Other file names.
   - Other extensions.
   - No extensions.
   - Configuration: No using of extensions.
   - Default index.jscp
 - Static files.
 - Static files requested with POST.



At this point, _manually test_ the rest (uploads, serving error files, etc.)
 - Maybe you can document your steps, for reference when implementing more tests in the future.
   - And then check that entries are already documented elsewhere in the document, and delete duplicates.

Then, refer to notes_testing.txt
