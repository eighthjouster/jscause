List of sanity checks:
======================

Go through the code and see what else needs to be tested that is not directly related to serving files.
 - Reading user files.
   - Static/dynamic.
     - May need jscCallback/jscThen/jscCatch
     +- Reach max number of files/directories.
       *- Done with no symbolic links and files only.
         +- Do it with:
           *- Just directories.
           *- Files and directories.
           +- Including symbolic links.
             +- Test for:
               +- Circular references.
     - Reach max file size.
     - Check that user modules compile.
       - Shouldn't there be a check for jscmFilesList length as well?
     - The presence of errorXXX files in other directories (should throw a warning.)
 - Caching user files.
   - Static/dynamic.
     - May need jscCallback/jscThen/jscCatch
 - Test webServer.jscContext
 - What else?

Uncomment:
// 'testBattery_001', //__RP

At this point, back up and....
PUBLISH AN ALPHA!

Then, go through the code and start testing content-related stuff:
  - Whether HTML stuff renders.
  - Forms / GET / POST.
     - Use big files just to make sure that processes don't go past the next test.
     - May need jscCallback/jscThen/jscCatch
  - JSON stuff.
  - File uploads.
    - Temporary upload files should be deleted.
     - May need jscCallback/jscThen/jscCatch
     - Use big files just to make sure that processes don't go past the next test.
  - Limits exceeded.  Timeouts.
     - May need jscCallback/jscThen/jscCatch
  - Callbacks.
     - May need jscCallback/jscThen/jscCatch
  - waitFor().
     - May need jscCallback/jscThen/jscCatch
  - rtThen() / rtCatch().
     - May need jscCallback/jscThen/jscCatch
  - Other rt's.
  - File operations.
     - May need jscCallback/jscThen/jscCatch
  - Redirects.
  - Cookies.
  - Error 400 / Error 500.
    - Static error 400, static error 500.
    - Other errors.
  +- Logging.
     *- Especially the file name auto-generation.
     *- May need jscCallback/jscThen/jscCatch
      +- Delete the log file and attempt to file log.  It should issue a warning.
        - Do this just with the server logging part.
        - Do this by putting a website with a setTimeout that logs before and after the timeout.
          - The first log is fine, the second log should happen when the file has been deleted (maybe half way through the timeout wait.)

      - Lock the log file (644) and attempt to file log.  It should issue a warning.
        - Do this just with the server logging part.
          - The first log is fine, the second log should happen when the file has been deleted (maybe half way through the timeout wait.)

  - At this point, resume engine development.
  - Publish another alpha.

Check all the output when running all the tests, in case there are inconsistencies (e.g., test says no console output, but console output ocurred.  Things like that.)

In the end, jscause_backup.conf can be either restored or deleted.


Do we ever use doRemoveDirectoryFromPathList()?
 - If not, consider removing it.  Or document its existence somehow.  I dunno...

- Leave this file to document future development that needs corresponding testings created.

In fact:

TO-DO:
======

(Order by priority)

- Logging:
  - What happens if opening the log file fails?
    - Or if the writing fails?
    - In essence, test: openAndWriteToLogFile() and writeLogToFile()

- Test the log queue failsafe code.  What happens when MAX_FILELOG_QUEUE_ENTRIES is reached?  Is it being handled as expected?

- Implementing (and checking) callTestPhaseIfAvailable() on the rest of the phase functions:
  - These implementations cannot be modeled after the ones that are already implemented (i.e., onTestBeforeStart, onBeforeTestEnd, onTestEnd, onUnitTestStarted).  Read on.
  - onExpectedLogMessagesPass - This one is very tricky.  It can happen while another function phase is waiting, messing up the current phase state after completing.
  - onServerStarted - same deal as with onExpectedLogMessagesPass?
  - onServerError - same deal as with onExpectedLogMessagesPass?

Documentation:
==============

If you use methods that require waiting to complete via a callback, use this.waitForDoneSignal() as the callback.  If you want to provide a custom callback, pass it as a parameter of waitForDoneSignal().  For example:
      testServer.close(this.waitForDoneSignal(() =>
      {
        console.log('This is called when close() completes.');
      }));
Now, for promises set this.waitForContinueTestingCall to true in the promise declaration, and call this.continueTesting() at the very end of the then() and catch() blocks.

waitForDoneSignal() can only be used once in a single phase function.  Trying to call it more than once will throw a critical error and abort testing.
 - A workaround would be using it at last nested callback, or put all the callbacks inside a Promise.all(), or similar approach.

Some on() calls could be called more than once if more than one server is started during the test.  Using onServerStartedOrError() and this.numberOfServersInvokedSofar to keep track of server invocations can help handle scenarios, well, post-server invocations.

