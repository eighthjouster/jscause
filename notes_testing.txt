List of sanity checks:
======================

- Test webServer.jscContext
 - What else?
   - Again, go through the code from top to bottom.  Anything that's not related to the actual operation of serving files and processing requests (uploading, json serving, etc.), do test at this point.
     - rtContext? The non user-serving parts.

Uncomment:
// 'testBattery_001', //__RP

At this point, _manually test_ the rest (uploads, serving error files, etc.)

At this point, back up and....
PUBLISH AN ALPHA!

Then, go through the code and start testing content-related stuff:
  - Whether HTML stuff renders.
  - Forms / GET / POST.
     - Use big files just to make sure that processes don't go past the next test.
     - May need jscCallback/jscThen/jscCatch
  - JSON stuff.
  - File uploads.
    - Temporary upload files should be deleted.
     - May need jscCallback/jscThen/jscCatch
     - Use big files just to make sure that processes don't go past the next test.
  - Limits exceeded.  Timeouts.
     - May need jscCallback/jscThen/jscCatch
  - Callbacks.
     - May need jscCallback/jscThen/jscCatch
  - waitFor().
     - May need jscCallback/jscThen/jscCatch
  - rtThen() / rtCatch().
     - May need jscCallback/jscThen/jscCatch
  - Other rt's.
  - File operations.
     - May need jscCallback/jscThen/jscCatch
  - Redirects.
  - Cookies.
  - Error 400 / Error 500.
    - Static error 400, static error 500.
    - Other errors.
  +- Logging.
     *- Especially the file name auto-generation.
     *- May need jscCallback/jscThen/jscCatch
      +- Delete the log file and attempt to file log.  It should issue a warning.
        - Do this just with the server logging part.
        - Hasn't this been implemented already?
        - Do this by putting a website with a setTimeout that logs before and after the timeout.
          - The first log is fine, the second log should happen when the file has been deleted (maybe half way through the timeout wait.)

      - Lock the log file (444 or whatever) and attempt to file log.  It should issue a warning.
        - Hasn't this been implemented already?
        - Do this just with the server logging part.
          - The first log is fine, the second log should happen when the file has been deleted (maybe half way through the timeout wait.)

  - At this point, resume engine development.
  - Publish another alpha.

Check all the output when running all the tests, in case there are inconsistencies (e.g., test says no console output, but console output ocurred.  Things like that.)

In the end, jscause_backup.conf can be either restored or deleted.


Do we ever use doRemoveDirectoryFromPathList()?
 - If not, consider removing it.  Or document its existence somehow.  I dunno...

- Leave this file to document future development that needs corresponding testings created.

In fact:

TO-DO:
======

(Order by priority)

Test that users get the following message when the log queue is, for some reason, full:
 - "WARNING! Log message queue full.  No entries are being logged to file.  Check permissions, storage space and/or filesystem health."
   - This can be a unit test.

Test that html 4xx/5xx error files prevail over jscp 4xx/5xx error files.

- Logging:
  - What happens if opening the log file fails?
    - Or if the writing fails?
    - In essence, test: openAndWriteToLogFile() and writeLogToFile()

- Test the log queue failsafe code.  What happens when MAX_FILELOG_QUEUE_ENTRIES is reached?  Is it being handled as expected?

- Implementing (and checking) callTestPhaseIfAvailable() on the rest of the phase functions:
  - These implementations cannot be modeled after the ones that are already implemented (i.e., onTestBeforeStart, onBeforeTestEnd, onTestEnd, onUnitTestStarted).  Read on.
  - onExpectedLogMessagesPass - This one is very tricky.  It can happen while another function phase is waiting, messing up the current phase state after completing.
  - onServerStarted - same deal as with onExpectedLogMessagesPass?
  - onServerError - same deal as with onExpectedLogMessagesPass?

 - Security-related testing:  poke for vulnerabilities; test that the app is secure.

Documentation:
==============

If you use methods that require waiting to complete via a callback, use this.waitForDoneSignal() as the callback.  If you want to provide a custom callback, pass it as a parameter of waitForDoneSignal().  For example:
      testServer.close(this.waitForDoneSignal(() =>
      {
        console.log('This is called when close() completes.');
      }));
Now, for promises set this.waitForContinueTestingCall to true in the promise declaration, and call this.continueTesting() at the very end of the then() and catch() blocks.

waitForDoneSignal() can only be used once in a single phase function.  Trying to call it more than once will throw a critical error and abort testing.
 - A workaround would be using it at last nested callback, or put all the callbacks inside a Promise.all(), or similar approach.

Some on() calls could be called more than once if more than one server is started during the test.  Using onServerStartedOrError() and this.numberOfServersInvokedSofar to keep track of server invocations can help handle scenarios, well, post-server invocations.

