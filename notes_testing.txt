List of sanity checks:
======================

- Implement (and check!) callTestPhaseIfAvailable() on:
  *- onTestBeforeStart
  *- onBeforeTestEnd
  *- onTestEnd
  *- onUnitTestStarted
  - expectedLogMessagesPass - This one is very tricky.  Might need to move to "the future" - and document if so, that is, indicate that waitForDoneSignal() is not supported here.)
     - Perhaps this function should be renamed since jscause calls it, and one function that is called and verified from within jsctest *only* is the one to be put in the test battery (which would imply to modify the base in test utils and the example.)
       - If too much trouble, just move to the future.
  - onServerStarted - same deal as with expectedLogMessagesPass?
  - onServerError - same deal as with expectedLogMessagesPass?
    - Then, continue designing the test.
      - test_014_001_takenServerPort.js

expectedLogMessagesPass should be renamed to onExpectedLogMessagesPass.

Test: What if a port is taken? (By some other application.)
 - Test with one site, then with two sites.

Go through the code and see what else needs to be tested that is not directly related to serving files.
 - Reading user files.
   - Static/dynamic.
     - May need jscCallback/jscThen/jscCatch
 - Caching user files.
   - Static/dynamic.
     - May need jscCallback/jscThen/jscCatch
 - Test webServer.jscContext
 - What else?

At this point, back up and....
PUBLISH AN ALPHA!

Then, go through the code and start testing content-related stuff:
  - Whether HTML stuff renders.
  - Forms / GET / POST.
     - Use big files just to make sure that processes don't go past the next test.
     - May need jscCallback/jscThen/jscCatch
  - JSON stuff.
  - File uploads.
    - Temporary upload files should be deleted.
     - May need jscCallback/jscThen/jscCatch
     - Use big files just to make sure that processes don't go past the next test.
  - Limits exceeded.  Timeouts.
     - May need jscCallback/jscThen/jscCatch
  - Callbacks.
     - May need jscCallback/jscThen/jscCatch
  - waitFor().
     - May need jscCallback/jscThen/jscCatch
  - rtThen() / rtCatch().
     - May need jscCallback/jscThen/jscCatch
  - Other rt's.
  - File operations.
     - May need jscCallback/jscThen/jscCatch
  - Redirects.
  - Cookies.
  - Error 400 / Error 500.
    - Static error 400, static error 500.
    - Other errors.
  +- Logging.
     *- Especially the file name auto-generation.
     *- May need jscCallback/jscThen/jscCatch
      +- Delete the log file and attempt to file log.  It should issue a warning.
        - Do this just with the server logging part.
        - Do this by putting a website with a setTimeout that logs before and after the timeout.
          - The first log is fine, the second log should happen when the file has been deleted (maybe half way through the timeout wait.)

      - Lock the log file (644) and attempt to file log.  It should issue a warning.
        - Do this just with the server logging part.
          - The first log is fine, the second log should happen when the file has been deleted (maybe half way through the timeout wait.)

  - At this point, resume engine development.
  - Publish another alpha.

Check all the output when running all the tests, in case there are inconsistencies (e.g., test says no console output, but console output ocurred.  Things like that.)

In the end, jscause_backup.conf can be either restored or deleted.


Do we ever use doRemoveDirectoryFromPathList()?
 - If not, consider removing it.  Or document its existence somehow.  I dunno...

- Leave this file to document future development that needs corresponding testings created.

In fact:

TO-DO:
======

(Order by priority)

- Logging:
  - What happens if opening the log file fails?
    - Or if the writing fails?
    - In essence, test: openAndWriteToLogFile() and writeLogToFile()

- Test the log queue failsafe code.  What happens when MAX_FILELOG_QUEUE_ENTRIES is reached?  Is it being handled as expected?

Documentation:
==============

If you use methods that require waiting to complete via a callback, use this.waitForDoneSignal() as the callback.  If you want to provide a custom callback, pass it as a parameter of waitForDoneSignal().  For example:
      testServer.close(this.waitForDoneSignal(() =>
      {
        console.log('This is called when close() completes.');
      }));
Now, for promises set this.waitForContinueTestingCall to true in the promise declaration, and call this.continueTesting() at the very end of the then() and catch() blocks.

waitForDoneSignal() can only be used once in a single phase function.  Trying to call it more than once will throw a critical error and abort testing.
 - A workaround would be using it at last nested callback, or put all the callbacks inside a Promise.all(), or similar approach.
