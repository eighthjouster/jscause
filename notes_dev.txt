Useful:
git bundle create jscause-.bundle devel
=====

Specify key and cert files on site config.

Address the //__RP

HTTPS on already assigned port? Throw warning.

When starting the server, report whether HTTPS is enabled.

Create unique servers based on port and https.
 - Don't mix two protocols, http/https, with the same port.

Make https work first.
 - //serverHttps = ?? //__RP
  Use the generated certs.

Laid out some ground work.  The configuration must be handled via jscause config to enable https first.  Then each site config to indicate whether it should support https or not (and in which port.)
 - If a site requires http but no http is configured, error.
 - Conversely, if a site requires https but no https is configured, error.
 - Global certs? Per-site certs?  Error if no certs found?
 - If all sites support http but not https, and https is enabled, emit a warning.  And shut down the unused server.
   - Vice-versa.

Document technical limitation of one server per HTTPS site.
 - JSCause should probably emit a warning.

What cert files can be removed without affecting anything?

Documentation:
  - Be _very_ clear that the certs provided should NOT be used in production.
    - As the matter of fact, I wonder if there is a way to detect them when the server starts and emit a warning if they are attempted to be used (by comparing them with a hash?) And only if https is attempted to be used.
    - Direct users to nodejs documentation on how to generate their own certs.
  - Disclaimer: very basic https implementation.  Something more robust/more exhaustive might be implenented in a future version.
  - httpsCertFile and httpsKeyFile are required if enableHTTPS is true.  Otherwise, they can be omited (BUT if included, their values must be valid; e.g., not empty string).

HTTPS?
 - Thorough documentation to do this.
   - Options to run http only, https only, or both http and https.
   - Step 1: Run https only.
   - Step 2: Run both http and https.
   - Step 3: Configuration option to choose what to run (one or both.)

Once you're done with https, merge to master, create version tag.
Then, merge (rebase) latest master changes with devel-cookies and continue developing cookies.

Cookies?
 - Read/write?
- Already added: const cookies = vendor_require('./jscvendor/cookies');
 - Now, implement.

Redirects?

HTTPS?
 - Thorough documentation to do this.

Server logging?
 - Access and errors.
 - Make sure that ERROR and INFO, which are normally displayed in color in a terminal, don't have weird characters surrounding them in a log text file.

Publish alpha version here.
 - Indicate what dependencies you're using (per MIT's license?).
   - jscvendor folder.

Databases.
 - Basic.

Server-side rendering?

Put in docs that a favicon.ico should be provided in the website root.

Watch for and reload changes at this point (hot reloading.)
 - And only the site it's affected, leaving the rest intact. - If possible.

Exposure of res and req, for advanced users.
 - But only if a config value allows it.

Log stdout and stderr to a configurable file.
 - Don't forget to check for directory existence and writeability.
   - There should be a default one.

Hard-coded values should go in a global file.

Are we vulnerable to this?
https://hackerone.com/reports/310439

At this point, divide up the engine into different files.
 - Make it one file using gulp or something, for prod.
   - Or just use your own setup file.

Handling server termination gracefully? (with Ctrl+C and/or process TERM/KILL/etc signaling)
 - Perhaps it should indicate at least that the application/process was terminated?

Syntax highlighters for Atom, VS Code, Vim, Sublime, Notepad++, TextWrangler.
 - Perhaps for future version.
   - Or outsource?

Make two versions:  Standalone and NPM-installable.

Does this work on Windows?

Remove these from /etc/hosts:
127.0.0.1       jscausesite1
127.0.0.1       jscausesite2

Version 0.7b here!
 - Upload to https://github.com/eighthjouster/jscause
 - Thanks to:
   - https://github.com/felixge/node-formidable   
   - https://github.com/parshap/node-sanitize-filename
   - https://github.com/pillarjs/cookies

 - Create a couple of sites with it.
 - Announce.
 
==========================

Order by priority:

JSCVendor folder: Use the original files, but hack them from your code.

We use jscmFilesList to check that modules compile.  Perhaps we can still use this during runtime as well?  Maybe the 'require' function prototype can be modified so it used the compiled code if available ("compiledCode.call({}, runTime)" just like it's used in responder(), try/catch and all.)

Shouldn't we check if a randomly generated upload file name exists previously before using?

- Optional routing configuration? (configuration/routes.js)

- A configuration flag to indicate whether a file or directory with a name starting with a dot ('.') should be served or not.  Right now, such files are not being served.

- The same file (e.g. through symbolic links) may be compiled/stored as static more than once.  How to optimize this?

- Global settings (per-site defaults.)  Also, indicate if sites can override them in their own files.
  - And if they can't, and they attempt it, warn.

- Resuming interrupted large downloads.

- Server throttling of large static files?

File encoding detection (for now, every file is assumed UTF-8.)
 - Take into account how both the file system and the browser treat special characters.

The values of the constants:
 - MAX_FILES_OR_DIRS_IN_DIRECTORY
 - MAX_DIRECTORIES_TO_PROCESS
 - MAX_PROCESSED_DIRECTORIES_THRESHOLD
 - MAX_CACHED_FILES_PER_SITE
 - MAX_CACHEABLE_FILE_SIZE_BYTES
should be configurable via a config file.

When defining a function and calling it inside a script, 'this' will refer to that of the node environment.  How to avoid this?  Or is this a "feature"? It should be an empty object.

- We have to start writing tests.
  - Define what needs to be tested.
  - Then outsource?

- Create/rename/delete directories?

- Easy way to write binary blobs and text.
  - Follow what rt.readFile() does.

- rt.readFile() alternative that returns a promise?  rt.readFilePromise()?

Decorator for rt.runAfter(() => {});
 - Something like:
    - <js-after begin /> does: <js rt.runAfter(() => { /js>
    - <js-after end /> does: <js }); /js>
    - Both blocks must be _outside_ of <js /js> blocks.

- Retriggable waitFor(), so stuff like on('data') can work. - Otherwise, the app will ignore later calls since the callback was dropped off the queue.
- Cancellable waitFor(), so stuff like retriggable waitFor(), or callbacks that may or may not execute can be cancelled from, say, an on('end') or on('error').
  - Perhaps there could be options, like: waitFor(cb1, { name: 'callback 1', retriggable: true }) and waitFor(cb2, { cancels: 'callback 1' }).

Any way to clean up the upload directory (the one specified in site.json) in case of a server error?
 - Maybe at startup?

 Any way to set fs permissions, so individual website processes can only read/write to their user directories only?

Databases, advanced features.

Uploading files:  When an upload form is submitted with no files specified, the framework still processes such files.  That is, a temp file is created, with size 0, I'm guessing.  And no filenames.
  - Any way to avoid the creation of an unnecessary file?

Plugins.  Something as easy as dropping as a folder in a /plugins folder.

JSCause modules.  They are regular npm modules, but certified with no external dependencies.

Better handling of max file size exceeded and uploads forbidden.

If the max file size is reached, the partial uploaded file remains in the system's temp directory.  Deal with this (I tried, I really tried, but just gave up after some time.)

Custom HTTP error pages - 404, 500, 403, etc.

Access to full url.

Set response status code?

Delete header entries?

Clear all header entries?

rt.waitFor():
 - There should be a way to define timeouts, to indicate when the callbacks are taking too long.
   - There should be a default somewhere, maybe 0 for "always wait."
   - If it times out, either throw an error, or run a user's function.

Reload on file change?

Option to crash the server on fatal error?
 - Crash it on immediate compile error.
 - Reload otherwise?

ESLint.

Compile everything? (not just wait for a runtime error to find out that a module has syntax errors.)
 - Don't waste too much time on this.  You can defer it to a future version.

jscp/jscm syntax coloring? linting?

Remove //__RP comments.

====

The framework should do this:
 - Enumerate the folders in sites/
   - Each folder will represent a site.

Implement: GET and POST.
 - Static pages.
Implement: Submit form data.
 - Ajax.
Implement: Talk to a databse.
Implement:
 - https
 - redirections
 - modules/plugins
   - redistributable packages
 - HTTP authentication?
 - How to avoid that the server dies on error?
   - Or at least it should restart itself.
     - Avoid endless loops?

How to hide the nodeJS way to do stuff and simplify as much as possible?

A way to do the "server pre-render" stuff.

Create a test to ensure all the opening/closing/<html/> tag rules according to the specs.

Security.
 - How to avoid, or at least warn or give control to the site, of DDOS by uploading large files or having too many requests?

Docs?

Better rtFileExists() implementation? I dunno, using rtOnError() to signify that the file doesn't exists seems... wrong?

===

Use cases:
 - Regular forms (no uploads).
 - Form uploads.
 - JSON.
   - And security, esp. file size.
 - Databases.
 - Cookies.
 - Redirects.
 - Multi-sites.
 - Server-side rendering (if not too complex.)
 - Other?
