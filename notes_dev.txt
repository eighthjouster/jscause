Useful:
git bundle create jscause-.bundle devel
=====

Check for circular symlinks:
 - A symlink that points to a directory, then a symlink inside that directory that points to the parent directory.
   - Will jscause freak out during initialization?

Symlinks?
 - We'll need to detect symlinks beforehand, then add them to allFiles.
   - We'll need to make a lot of test cases.
     - Whether the link points to an absolute path.
     - Whether the link points to a directory.
     - Whether the link points to a file name.
     - Whether the pointed directory or file has been processed already (but do create the path still? Different "routes" to the same file.  Interesting.)
       - Perhaps currentDirectoryId (and equivalent for single file) might help.

Get all the JSCP files inside the website directory and put them in the fileNameList array.
 - Check that at least one file was processed.  Otherwise, throw an error.
 - Careful with circular symlinks.
   - Circularly linked directories.
   - Circularly linked files.

 - Address the __RP

At this point, back up.

Call the right file depending on the url.
 - Only try to run if it's a JSCP file.
 - Throw a 404 if a JSCM file is requested.
 - Otherwise, serve as static.
 - Check for directories (/directory/index2.php)
 - Check for files without extensions.
   - Put in documentation (but check that everything mentioned has been implemented):
     1. If the url is '/', '/index.jscp' will be assumed (see #5).
     2. If the url is '/name' and the file 'name' does not exist, check if a 'name' directory exists.  If it does, assume '/name/index.jscp' (see #5).
     3. If the url is '/name' (for example '/index'), and the file 'name' (without an extension) exists, JSCause will serve the contents of such file.
     4. If the url is '/name.extension', with the extension being neither jscp nor jscm, JSCause will serve the contents of such file.
     5. If the url is '/name.jscp' (or '/directory/name.jscp'), then JSCause will run the contents and serve its output.
     6. If the extension is jscm, serve a 404.
     7. If none of the above applies, serve a 404.

With a setting, indicate if a url needs to hide the jscp extension (for security purposes).
 - And document.
With a setting, indicate if the header 'X-Powered-By: jscause' should be included in the response (off by default)
 - And document.

Serve files other than index.jscp
 - Multiple compilations, one per file.  Do it at the very beginning.
   - Check that runtime errors correctly indicate the file the error happened in (right now it only reports index.jscp.)
     - Report in modules? At least it should say the file the module was called from.
 - Call responder() only on jscp files.  The rest, treat as static downloads.
 - And _NEVER_ serve .jscm files.  Ever.
   - A directive to blacklist/whitelist directories from which .js files can be served as static files.
     - When absent, all .js is blacklisted.
   - And document this restriction.
Other files? (images, css, js).
 - Static files?
 - Files in assets/ directory?
   - If there are modules in there, it should be easy to access them.
 - Optional 4xx.jscp and 5xx.jscp files to run something when a 4xx or 5xx error occurs.
   - Same for 4xx.html and 5xx.html
   - And document.

- Make _really_ sure that .. won't access anything outside the website/ folder.

Cookies?
 - Read/write?

Redirects?

HTTPS?
 - Thorough documentation to do this.

Are we vulnerable to this?
https://hackerone.com/reports/310439

At this point, divide up the engine into different files.
 - Make it one file using gulp or something, for prod.

Watch for and reload changes at this point.
 - And only the site it's affected, leaving the rest intact. - If possible.

Server-side rendering?

Server logging?
 - Access and errors.
 - Make sure that ERROR and INFO, which are normally displayed in color in a terminal, don't have weird characters surrounding them in a log text file.

Handling server termination gracefully? (with Ctrl+C and/or process TERM/KILL/etc signaling)
 - Perhaps it should indicate at least that the application/process was terminated?

Route to site.

Databases.
 - Basic.

Shouldn't we check if a randomly generated upload file name exists previously before using?

Exposure of res and req, for advanced users.
 - But only if a config value allows it.

Log stdout and stderr to a configurable file.
 - Don't forget to check for directory existence and writeability.
   - There should be a default one.

Hard-coded values should go in a global file.

Syntax highlighters for Atom, VS Code, Vim, Sublime, Notepad++, TextWrangler.

Make two versions:  Standalone and NPM-installable.

Does this work on Windows?

Remove these from /etc/hosts:
127.0.0.1       jscausesite1
127.0.0.1       jscausesite2

Version 0.7b here!
 - Upload to https://github.com/eighthjouster/jscause
 - Thanks to:
   - Formidable.
   - https://github.com/parshap/node-sanitize-filename

 - Create a couple of sites with it.
 - Announce.
 
==========================

Order by priority:

When defining a function and calling it inside a script, 'this' will refer to that of the node environment.  How to avoid this?  Or is this a "feature"? It should be an empty object.

- We have to start writing tests.
  - Define what needs to be tested.
  - Then outsource?

- Create/rename/delete directories?

- Easy way to write binary blobs and text.
  - Follow what rt.readFile() does.

- rt.readFile() alternative that returns a promise?  rt.readFilePromise()?

Decorator for rt.runAfter(() => {});
 - Something like:
    - <js-after begin /> does: <js rt.runAfter(() => { /js>
    - <js-after end /> does: <js }); /js>
    - Both blocks must be _outside_ of <js /js> blocks.

- Retriggable waitFor(), so stuff like on('data') can work. - Otherwise, the app will ignore later calls since the callback was dropped off the queue.
- Cancellable waitFor(), so stuff like retriggable waitFor(), or callbacks that may or may not execute can be cancelled from, say, an on('end') or on('error').
  - Perhaps there could be options, like: waitFor(cb1, { name: 'callback 1', retriggable: true }) and waitFor(cb2, { cancels: 'callback 1' }).

Any way to clean up the upload directory (the one specified in site.json) in case of a server error?
 - Maybe at startup?

 Any way to set fs permissions, so individual website processes can only read/write to their user directories only?

Databases, advanced features.

Uploading files:  When an upload form is submitted with no files specified, the framework still processes such files.  That is, a temp file is created, with size 0, I'm guessing.  And no filenames.
  - Any way to avoid the creation of an unnecessary file?

Plugins.  Something as easy as dropping as a folder in a /plugins folder.

Better handling of max file size exceeded and uploads forbidden.

If the max file size is reached, the partial uploaded file remains in the system's temp directory.  Deal with this (I tried, I really tried, but just gave up after some time.)

Custom HTTP error pages - 404, 500, 403, etc.

Access to full url.

Set response status code?

Delete header entries?

Clear all header entries?

rt.waitFor():
 - There should be a way to define timeouts, to indicate when the callbacks are taking too long.
   - There should be a default somewhere, maybe 0 for "always wait."
   - If it times out, either throw an error, or run a user's function.

Reload on file change?

Option to crash the server on fatal error?
 - Crash it on immediate compile error.
 - Reload otherwise?

ESLint.

Compile everything? (not just wait for a runtime error to find out that a module has syntax errors.)
 - Don't waste too much time on this.  You can defer it to a future version.

jscp/jscm syntax coloring? linting?

Remove //__RP comments.

====

The framework should do this:
 - Enumerate the folders in sites/
   - Each folder will represent a site.

- Implement:
  public/, json/, files/, site_routes.json and scripts/ must allow hot reloading.

Implement: GET and POST.
 - Static pages.
Implement: Submit form data.
 - Ajax.
Implement: Talk to a databse.
Implement:
 - https
 - redirections
 - modules/plugins
   - redistributable packages
 - HTTP authentication?
 - How to avoid that the server dies on error?
   - Or at least it should restart itself.
     - Avoid endless loops?

How to hide the nodeJS way to do stuff and simplify as much as possible?

A way to do the "server pre-render" stuff.

Create a test to ensure all the opening/closing/<html/> tag rules according to the specs.

Security.
 - How to avoid, or at least warn or give control to the site, of DDOS by uploading large files or having too many requests?

Docs?

Better rtFileExists() implementation? I dunno, using rtOnError() to signify that the file doesn't exists seems... wrong?

===

Use cases:
 - Regular forms (no uploads).
 - Form uploads.
 - JSON.
   - And security, esp. file size.
 - Databases.
 - Cookies.
 - Redirects.
 - Multi-sites.
 - Server-side rendering (if not too complex.)
 - Other?
