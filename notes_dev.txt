Useful:
git bundle create jscause-.bundle devel
=====

Hmmm, perhaps we can avoid this whole "provide rtThen()" altogether?
  - Done, but we need to:
    - Maybe refactor a bit, for readability.  It seems too spaghetti.
    - Test exhaustively.  Esp. with nested cases.
  - And update behavior in the documentation (the part that talks about 'rtThen() can be omitted but this is not advisable!').

Then merge devel-default-promises into devel, and BACKUP!

Delete the temp files from Desktop/, if any.

Easy file manipulation:
 - Easy way to check that files exist.
     - Use rt.readFile() as a model.
   - And document.

- Rename rtThen and rtCatch to rtOnSuccess and rtOnError.

- A bit of documentation at this point?
 - Just tweaking what we have in notes_specs.txt so it reflects the latest changes.

- But wait, why do we have default values, if omitting keywords is forbidden, then?
   - e.g. DEFAULT_HOSTNAME? DEFAULT_PORT?

What is 'this' in our environment context?  Find out, document if necessary.
 - So far, it's {}.  I think it should be undefined.
   - Check inside callbacks and waitFor() callbacks as well:
     - cb.apply({}, arguments);
     - indexRun.call({}, runTime);

Git tag at this point.

Are file error codes the same in Linux, MacOS and Windows? (err.code === 'EEXIST', for example.)
 - Check moveFile with overwrite=false, for example.

There should be two directories:  jscause and sites, sitting side by side.

Serve files other than index.jscp
 - Multiple compilations, one per file.
 - Call responder() only on jscp files.  The rest, treat as static downloads.
 - And _NEVER_ serve .jscm files.  Ever.
   - A directive to blacklist/whitelist directories from which .js files can be served as static files.
     - When absent, all .js is blacklisted.
   - And document this restriction.
Other files? (images, css, js).
 - Static files?
 - Files in assets/ directory?
   - If there are modules in there, it should be easy to access them.

Cookies?
 - Read/write?

Redirects?

HTTPS?
 - Thorough documentation to do this.

Are we vulnerable to this?
https://hackerone.com/reports/310439

At this point, divide up the engine into different files.
 - Make it one file using gulp or something, for prod.

Watch for and reload changes at this point.
 - And only the site it's affected, leaving the rest intact. - If possible.

Server-side rendering?

Server logging?
 - Access and errors.
 - Make sure that ERROR and INFO, which are normally displayed in color in a terminal, don't have weird characters surrounding them in a log text file.

Handling server termination gracefully? (with Ctrl+C and/or process TERM/KILL/etc signaling)
 - Perhaps it should indicate at least that the application/process was terminated?

Route to site.

Databases.
 - Basic.

Shouldn't we check if a randomly generated upload file name exists previously before using?

Exposure of res and req, for advanced users.
 - But only if a config value allows it.

Log stdout and stderr to a configurable file.
 - Don't forget to check for directory existence and writeability.
   - There should be a default one.

Hard-coded values should go in a global file.

Syntax highlighters for Atom, VS Code, Vim, Sublime, Notepad++, TextWrangler.

Make two versions:  Standalone and NPM-installable.

Does this work on Windows?

Remove these from /etc/hosts:
127.0.0.1       jscausesite1
127.0.0.1       jscausesite2

Version 0.7b here!
 - Upload to https://github.com/eighthjouster/jscause
 - Thanks to:
   - Formidable.
   - https://github.com/parshap/node-sanitize-filename

 - Create a couple of sites with it.
 - Announce.
 
==========================

Order by priority:

- We have to start writing tests.
  - Define what needs to be tested.
  - Then outsource?

- Create/rename/delete directories?

- Easy way to write binary blobs and text.
  - Follow what rt.readFile() does.

- rt.readFile() alternative that returns a promise?  rt.readFilePromise()?

Decorator for rt.runAfter(() => {});
 - Something like:
    - <js-after begin /> does: <js rt.runAfter(() => { /js>
    - <js-after end /> does: <js }); /js>
    - Both blocks must be _outside_ of <js /js> blocks.

- Retriggable waitFor(), so stuff like on('data') can work. - Otherwise, the app will ignore later calls since the callback was dropped off the queue.
- Cancellable waitFor(), so stuff like retriggable waitFor(), or callbacks that may or may not execute can be cancelled from, say, an on('end') or on('error').
  - Perhaps there could be options, like: waitFor(cb1, { name: 'callback 1', retriggable: true }) and waitFor(cb2, { cancels: 'callback 1' }).

Any way to clean up the upload directory (the one specified in site.json) in case of a server error?
 - Maybe at startup?

 Any way to set fs permissions, so individual website processes can only read/write to their user directories only?

Databases, advanced features.

Uploading files:  When an upload form is submitted with no files specified, the framework still processes such files.  That is, a temp file is created, with size 0, I'm guessing.  And no filenames.
  - Any way to avoid the creation of an unnecessary file?

Plugins.  Something as easy as dropping as a folder in a /plugins folder.

Better handling of max file size exceeded and uploads forbidden.

If the max file size is reached, the partial uploaded file remains in the system's temp directory.  Deal with this (I tried, I really tried, but just gave up after some time.)

Custom HTTP error pages - 404, 500, 403, etc.

Access to full url.

Set response status code?

Delete header entries?

Clear all header entries?

rt.waitFor():
 - There should be a way to define timeouts, to indicate when the callbacks are taking too long.
   - There should be a default somewhere, maybe 0 for "always wait."
   - If it times out, either throw an error, or run a user's function.

Reload on file change?

Option to crash the server on fatal error?
 - Crash it on immediate compile error.
 - Reload otherwise?

ESLint.

Compile everything? (not just wait for a runtime error to find out that a module has syntax errors.)
 - Don't waste too much time on this.  You can defer it to a future version.

jscp/jscm syntax coloring? linting?

Remove __RP comments.

====

The framework should do this:
 - Enumerate the folders in sites/
   - Each folder will represent a site.

- Implement:
  public/, json/, files/, site_routes.json and scripts/ must allow hot reloading.

Implement: GET and POST.
 - Static pages.
Implement: Submit form data.
 - Ajax.
Implement: Talk to a databse.
Implement:
 - https
 - redirections
 - modules/plugins
   - redistributable packages
 - HTTP authentication?
 - How to avoid that the server dies on error?
   - Or at least it should restart itself.
     - Avoid endless loops?

How to hide the nodeJS way to do stuff and simplify as much as possible?

A way to do the "server pre-render" stuff.

Create a test to ensure all the opening/closing/<html/> tag rules according to the specs.

Security.
 - How to avoid, or at least warn or give control to the site, of DDOS by uploading large files or having too many requests?

Docs?

===

Use cases:
 - Regular forms (no uploads).
 - Form uploads.
 - JSON.
   - And security, esp. file size.
 - Databases.
 - Cookies.
 - Redirects.
 - Multi-sites.
 - Server-side rendering (if not too complex.)
 - Other?
