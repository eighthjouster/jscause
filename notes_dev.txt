Useful:
git bundle create jscause-.bundle devel
=====

Can POST/PUT/DELETE requests refer to error4xx and error5xx files? What to do in these cases?
  - Allow it?!?!

Sample site:
 - Ok, backtracking:
   - And no nginx, no apache (but how to use Vesta, then?)
   - Install Vesta in the new linode.
   - All ports closed except for ssh (random one?), 80 and 443.
   - Install node.
   - Install jscause, make it work (it should run.)
   - See if you can access it from outside via HTTP.

- At this point, undo any jscsite work on rppalencia.
   - And configure https.

Time to convert those tests in notes_testing.txt to actual tests.

The last test should call doEmptyTestDirectory()

So far:
 - Check for pending work in notes_testing.txt

In the specs:
- jscause.conf:  Global enclosing curly brackets are optional.
  - Does this still count?  Check the testing.

Did you know that site names can be anything? Like "{}" will be converted to "[Object object]".
 - If we decide to leave this, document.
   - If we decide to correct it, update the tests to check that this behavior doesn't happen.

Don't forget that we have this logOptions param in checkExpectedLogMessages().

Perform exhaustive testing at this point.
 - Document every step you do in notes_testing.txt
   - You must test comments, // and /* */ in json files.

Can guest jscp scripts create globals that can then be read by jscause internal functions? I hope not.  This would be a security risk.

Do we need onServerStarted, onServerError, onTerminateComplete?

Maybe: In some automated tests in which the server shut downs normally (ctrl+C?), they should wait for the server to shut down completely (e.g. allow time to close all the log files.)

 - Back up, please.

Strange: two slashes in a path will render jscause.conf invalid:
"rootDirectoryName": "//mysite",
Why? Parser bug?

- Document: logFileSizeThreshold
  - general logging only.  perSite logging does not allow it.

There should be one JSCLogMessageQueue and one isJSCLogMessageQueueProcessing per site and for the global server.

- Logging rotation?
  - Max size of uncompressed log files? (default: 1 MB).
    *- -1, -2, -3 for the same date. - Done.
      *- 30-second mod debug mode for file names already enabled.
        +- And document. - on it.
  - Keep the last N files? (0 for keep everything).
    - Do the configuration first.  Follow the logFileSizeThreshold route.
      - Actually, see if you can convert parameters to context object in certain situations first.
        - Example: handleError4xx(()
          - Yeah, why don't you pass identifiedSite directly to those?

In the docs so far:
  - Log files can be limited by size.  When the limit is reached, a new log file will be created, with identical name as the previous one, but with a numeric suffix (e.g. --1, --2, etc).  The previous file will be compressed.
  - If you move compressed log files to another location, and JSCause is writing to a suffixed file, then it will reset writing to a non-suffixed file.  This will cause log entries that will appear as out of sync with the files they're in.  Worse, next time a move occurs, the newly created log file will overwrite the one previously existing in the destination.  To avoid this, your move procedure should leave all the compressed suffixed files associated with the current (non-compressed) log file.

- Output to log file in bulk (every 500ms or so) and async (throttle/debounce).
    - That check about whether we're on the right file to log? Do it _before_ debouncing.
      - Same with archiving checks.
    - Document this behavior.

Do we need this?
else if (process.argv[2] === 'testmode')
 - If we do, DOCUMENT.

If I put on site.json:
"fileOutput": "disbled",
(notice that there is a typo),
the server will emit an error, but will allow the listening to continue.
  - The server shouldn't allow the listening, correct?
  - Still happening?

On getDirectoryPathAndCheckIfWritable():
 - Why do directory paths need to be writable? Maybe the log directories, but nothing else...

- Test thoroughly.
  - Simulate and test all the errors.
    - Including the console.warn()
    - Tests should only run in dev mode.

Some work has been put into place.
 - Document whatever is not documented below before deleting.
   - Site-wide:
     - Logging type: {
         general: {
           fileOutput: 'enabled|disabled', [enabled by default.]
           directoryName: '', ['jscause/logs' by default.]
           consoleOutput: 'enabled|disabled' [enabled by default]
         },
         perSite: {
           fileOutput: 'enabled|disabled|per site' [disabled by default.]
           consoleOutput: 'enabled|disabled|per site' enabled by default. (per site = let the site configuration decide)
         }
     - Per site:
      - Logging type:
        {
          fileOutput: 'enabled|disabled', [disabled by default] [Might be overridden by site-wide config]
          directoryName: '', ['website/logs' by default.] [if either fileOutput above or site-wide fileOutput perSite config is enabled, you MUST provide a name here.]
            - Remember:
              - Test with paths that aren't directories. - Done.
              - Test with read-only directories. - Done.
              - Test with symbolic links. - Done.
          consoleOutput: 'enabled|disabled' enabled by default. [Might be overridden by site-wide config]
        }

Documentation:
  - Overrides.
  - If there are reading/writing errors to log files, no further logging will take place until it's time to rotate the files.  If console output is enabled, the server will emit warnings on file operation errors.
  - Site-wide allowances/prohibitions.
  - Mandatory values (e.g. logging output if site-wide mandates it.)
  - logging key in jscause.conf is optional, unlike "sites".
  - Per-site: Even if file logging is disabled, if a file name/path is provided, it must be valid.
    - You can comment it out if you'd rather not provide one.  But logging MUST be disabled.
  - General: A missing or empty directoryname will be assumed "logs".  A logging directory must exist regardless of whether logging is enabled or disabled.
  - Compression of log files will happen four at a time.  The rest will be queued.
    - The process of determining log compressing on a specific site will happen only when there is something to log.  If there are uncompressed log files, and the site is never accessed, or nothing is logged, the files will remain uncompressed.

Documentation: Ctrl+C or SIGINT will terminate the server gracefully:
  - It will close the log files.
  - If there are any log files being compressed at that very moment, it will wait until the operation completes.  Any pending log files to compress will be ignored after that.
  - A second Ctrl+C during cleanup will let the user know that cleanup is still happening.
  - A third Ctrl+C will terminate the program immediately, even if cleanup was happening.

- Documentation:  nodejs jscause.js runtests
  - If the tests are not present, do not even try to run them.

Server logging?
 - Access and errors.
   - Must be a configuration.
     - No configuration? No logging.  But a WARNING must be issued.
 - Make sure that ERROR and INFO, which are normally displayed in color in a terminal, don't have weird characters surrounding them in a log text file.

Get rid of __RP.

Can two no-name sites exist?  In theory they share the same name, and the server should not start, just like it does with two sites with identical names.

At this point, back up.

Put regex literals outside of functions (like in handleCustomError).

We'll need to put more code into functions.
 - Run the tests after this.

And back up again.

Ability to write to files?
  - Text and binary.
  - Put pending testing work in notes_testing.txt

You need to break down incomingRequestHandler.
 - And validateLoggingConfigSection.
 - And definitely startApplication.

Deal with this (it happened on linode; I'm guessing I can get it locally if I upgrade node):
(node:9833) [DEP0005] DeprecationWarning: Buffer() is deprecated due to security and usability issues. Please use the Buffer.alloc(), Buffer.allocUnsafe(), or Buffer.from() methods instead.

Ability to provide an alias for a server, so the same content can served from two host names.  For example, from example.com and www.example.com:
On the site.json file:
"hostName": "jscsite.net,www.jscsite.net"

Back up.

Databases.
 - Basic.
   - We'll use MariaDB.
     - https://www.npmjs.com/package/mariadb
       - Just 4 dependencies.

Update notes_testing.txt with any testing that needs to be implemented.

Put in docs that a favicon.ico should be provided in the website root.
 - Put your own favicon.ico meanwhile.
   - Or at least test that it works as intended.

Watch for and reload changes at this point (hot reloading.)
 - And only the site it's affected, leaving the rest intact. - If possible.

Exposure of res and req, for advanced users.
 - But only if a config value allows it.

Log stdout and stderr to a configurable file.
 - Don't forget to check for directory existence and writeability.
   - There should be a default one.

Hard-coded values should go in a global file.

Are we vulnerable to this?
https://hackerone.com/reports/310439

At this point, divide up the engine into different files.
 - Make it one file using gulp or something, for prod.
   - Or just use your own setup file.
  - Check that everything passes testing.

Formalize the documentation.
 - Including some JSCause dev documentation (how to contribute, how to add new dependencies to JSCVendor, etc.)

Publish 0.7.0a version here.
 - Indicate what dependencies you're using (per MIT's license?).
   - jscvendor folder.

Syntax highlighters for Atom, VS Code, Vim, Sublime, Notepad++, TextWrangler.
 - Perhaps for future version.
   - Or outsource?

Make two versions:  Standalone and NPM-installable.

Does this work on Windows?

Remove these from /etc/hosts:
127.0.0.1       jscausesite1
127.0.0.1       jscausesite2

Version 0.7.1b here!
 - Upload to https://github.com/eighthjouster/jscause
 - Thanks to:
   - https://github.com/felixge/node-formidable   
   - https://github.com/parshap/node-sanitize-filename
   - https://github.com/pillarjs/cookies

 - Create a couple of sites with it.
 - Announce.
 
==========================

Order by priority:

Address:
// TO-DO: We need try/catch here. If error, include ${key} on the reporting.

You should make sure that error4XX and 5XX files are cached (if they're within the threshold).  That is, they should be considered first.
 - And test for this.

Easily send e-mail.

If there is a log file open/write/append failure, keep the message and wait a few milliseconds before retrying.
 - With tests.
 - And if you implement this, make sure that the checks to prevent that JSCLogMessageQueue grows indefinitely are in place and working correctly in this scenario.

When the logging system is looking for the next file to log to ("--1.log", "--2.log", etc), even if it finds one with content size below the threshold, it should make sure that no file exists with the next "--N.log" name before writing.  Otherwise, it must keep searching on.  For instance:  if it finds that "--5.log" is below the threshold, but there exists "--6.log", it must continue with "--6.log".  If that file is below the threshold, and "--7.log" does not exist, then it's okay to use for logging.

Testing battery:
 - What if either the cert of key file can be base64 decoded, but the info inside is bad?
   - Will the server fail?  It should.  Test this, if you can.  But don't sweat too much about it.

During compression, the final file should not be .gz but something like .gz.tmp, then renamed to .gz when the compression is done.

Server side HTTP transfer compression?

Do we ever use allOpenLogFiles[filePath].errorStatus?  At least mention it somewhere in a "dev doc"?

As it is now, if writing a log message to file fails, the file will be closed, the attempt will be dropped (so the message is lost), and for next time, another openSync() attempt is made.  This means that performance can degrade if constant logging failures happen.  How to address this?  And how to let the user/sysadmin know?

async/await approach instead of callbacks? Co-routine approach?

More filesystem functions? We have readFile, deleteFile, possibly writeFile... but no more granular options, like opening/closing files and writing to them whenever the developer wants.

rt.exit()? No waiting for setTimeouts and the like?
 - Documentation:  If any callback-based operation scheduled, they will still happen but the JSCause won't wait for them. - Dangerous!
   - Doable?  Consider it.  Future version.
   - If you do this, maybe mention it in the redirection documentation (redirect then exit()).

We use jscmFilesList to check that modules compile.  Perhaps we can still use this during runtime as well?  Maybe the 'require' function prototype can be modified so it used the compiled code if available ("compiledCode.call({}, runTime)" just like it's used in responder(), try/catch and all.)
 - Isn't this happening already?

Shouldn't we check if a randomly generated upload file name exists previously before using?

- Optional routing configuration? (configuration/routes.js)

- A configuration flag to indicate whether a file or directory with a name starting with a dot ('.') should be served or not.  Right now, such files are not being served.

- The same file (e.g. through symbolic links) may be compiled/stored as static more than once.  How to optimize this?

- Global settings (per-site defaults.)  Also, indicate if sites can override them in their own files.
  - And if they can't, and they attempt it, warn.

- Resuming interrupted large downloads.

- Server throttling of large static files?

File encoding detection (for now, every file is assumed UTF-8.)
 - Take into account how both the file system and the browser treat special characters.

The values of the constants:
 - MAX_FILES_OR_DIRS_IN_DIRECTORY
 - MAX_DIRECTORIES_TO_PROCESS
 - MAX_PROCESSED_DIRECTORIES_THRESHOLD
 - MAX_CACHED_FILES_PER_SITE
 - MAX_CACHEABLE_FILE_SIZE_BYTES
should be configurable via a config file.

When defining a function and calling it inside a script, 'this' will refer to that of the node environment.  How to avoid this?  Or is this a "feature"? It should be an empty object.

- We have to start writing tests.
  - Define what needs to be tested.
  - Then outsource?

- Create/rename/delete directories?

- Easy way to write binary blobs and text.
  - Follow what rt.readFile() does.

- rt.readFile() alternative that returns a promise?  rt.readFilePromise()?

Decorator for rt.runAfter(() => {});
 - Something like:
    - <js-after begin /> does: <js rt.runAfter(() => { /js>
    - <js-after end /> does: <js }); /js>
    - Both blocks must be _outside_ of <js /js> blocks.

- Retriggable waitFor(), so stuff like on('data') can work. - Otherwise, the app will ignore later calls since the callback was dropped off the queue.
- Cancellable waitFor(), so stuff like retriggable waitFor(), or callbacks that may or may not execute can be cancelled from, say, an on('end') or on('error').
  - Perhaps there could be options, like: waitFor(cb1, { name: 'callback 1', retriggable: true }) and waitFor(cb2, { cancels: 'callback 1' }).

Any way to clean up the upload directory (the one specified in site.json) in case of a server error?
 - Maybe at startup?

 Any way to set fs permissions, so individual website processes can only read/write to their user directories only?

Databases, advanced features.

Uploading files:  When an upload form is submitted with no files specified, the framework still processes such files.  That is, a temp file is created, with size 0, I'm guessing.  And no filenames.
  - Any way to avoid the creation of an unnecessary file?

Plugins.  Something as easy as dropping as a folder in a /plugins folder.

Server-side rendering?
  - For just-HTML-rendering: A way to render in-line before delivering HTML?
    - If you consider the plugin model, this is where you lay the groundwork.
  - For combined API calls: Deliver the state as a one-time payload?
  - As a module/plugin?

JSCause modules.  They are regular npm modules, but certified with no external dependencies.

Better handling of max file size exceeded and uploads forbidden.

If the max file size is reached, the partial uploaded file remains in the system's temp directory.  Deal with this (I tried, I really tried, but just gave up after some time.)

Custom HTTP error pages - 404, 500, 403, etc.

Access to full url.

Set response status code?

Delete header entries?

Clear all header entries?

Perhaps in a not so distant future we can arrange the code so that jscCallback, jscThen and jscCatch are true NOOPs in production.

rt.waitFor():
 - There should be a way to define timeouts, to indicate when the callbacks are taking too long.
   - There should be a default somewhere, maybe 0 for "always wait."
   - If it times out, either throw an error, or run a user's function.

Reload on file change?

Cleaner way to process.exit()? (or avoid using it altogether.)

Option to crash the server on fatal error?
 - Crash it on immediate compile error.
 - Reload otherwise?

ESLint.

Compile everything? (not just wait for a runtime error to find out that a module has syntax errors.)
 - Don't waste too much time on this.  You can defer it to a future version.

jscp/jscm syntax coloring? linting?

Remove //__RP comments.

====

The framework should do this:
 - Enumerate the folders in sites/
   - Each folder will represent a site.

Implement: GET and POST.
 - Static pages.
Implement: Submit form data.
 - Ajax.
Implement: Talk to a database.
Implement:
 - https
 - redirections
 - modules/plugins
   - redistributable packages
 - HTTP authentication?
 - How to avoid that the server dies on error?
   - Or at least it should restart itself.
     - Avoid endless loops?

How to hide the nodeJS way to do stuff and simplify as much as possible?

A way to do the "server pre-render" stuff.

Create a test to ensure all the opening/closing/<html/> tag rules according to the specs.

Security.
 - How to avoid, or at least warn or give control to the site, of DDOS by uploading large files or having too many requests?
 - SSL cypher downgrade attacks?

Docs?

Better rtFileExists() implementation? I dunno, using rtOnError() to signify that the file doesn't exists seems... wrong?

===

Use cases:
 - Regular forms (no uploads).
 - Form uploads.
 - JSON.
   - And security, esp. file size.
 - Databases.
 - Cookies.
 - Redirects.
 - Multi-sites.
 - Server-side rendering (if not too complex.)
 - Other?
