Useful:
git bundle create jscause-.bundle devel
=====

You will need to test every resEnd() call just to make sure that serverLogging and siteLogging are being correctly passed as parameters.
 - And hostName.

Now, on to actual logging:
 - Address: //__RP - For now.
  - Console output first.
    - Should port and protocol (e.g. https) be logged too?
  - File output next (based on console output)
    - Don't log terminal color codes.
     - And write to file in bulk (every 500ms or so) and deferred.
       - Write the last batch on Ctrl+C?
    - Logging rotation?
      - Use require('zlib'), which is built-in (nice!)

Some work has been put into place.
 - Document whatever is not documented below before deleting.
   - Site-wide:
     - Logging type: {
         general: {
           fileOutput: 'enabled|disabled', [enabled by default.]
           directoryName: '', ['jscause/logs' by default.]
           consoleOutput: 'enabled|disabled' [enabled by default]
         },
         perSite: {
           fileOutput: 'enabled|disabled|per site' [diabled by default.]
           consoleOutput: 'enabled|disabled|per site' enabled by default. (per site = let the site configuration decide)
         }
     - Per site:
      - Logging type:
        {
          fileOutput: 'enabled|disabled', [disabled by default] [Might be overridden by site-wide config]
          directoryName: '', ['website/logs' by default.] [if either fileOutput above or site-wide fileOutput perSite config is enabled, you MUST provide a name here.]
            - Remember:
              - Test with paths that aren't directories. - Done.
              - Test with read-only directories. - Done.
              - Test with symbolic links. - Done.
          consoleOutput: 'enabled|disabled' enabled by default. [Might be overridden by site-wide config]
        }

Documentation:
  - Overrides.
  - Site-wide allowances/prohibitions.
  - Mandatory values (e.g. logging output if site-wide mandates it.)
  - logging key in jscause.conf is optional, unlike "sites".
  - Per-site: Even if file logging is disabled, if a file name/path is provided, it must be valid.
    - You can comment it out if you'd rather not provide one.  But logging MUST be disabled.
  - General: A missing or empty directoryname will be assumed "logs".  A logging directory must exist regardless of whether logging is enabled or disabled.

Server logging?
 - Access and errors.
   - Must be a configuration.
     - No configuration? No logging.  But a WARNING must be issued.
 - Make sure that ERROR and INFO, which are normally displayed in color in a terminal, don't have weird characters surrounding them in a log text file.

Get rid of __RP.

Can two no-name sites exist?  In theory they share the same name, and the server should not start, just like it does with two sites with identical names.

At this point, back up.

We'll need to put more code into functions.

And back up again.

Databases.
 - Basic.
   - We'll use MariaDB.
     - https://www.npmjs.com/package/mariadb
       - Just 4 dependencies.

Put in docs that a favicon.ico should be provided in the website root.
 - Put your own favicon.ico meanwhile.
   - Or at least test that it works as intended.

Watch for and reload changes at this point (hot reloading.)
 - And only the site it's affected, leaving the rest intact. - If possible.

Exposure of res and req, for advanced users.
 - But only if a config value allows it.

Log stdout and stderr to a configurable file.
 - Don't forget to check for directory existence and writeability.
   - There should be a default one.

Hard-coded values should go in a global file.

Are we vulnerable to this?
https://hackerone.com/reports/310439

At this point, divide up the engine into different files.
 - Make it one file using gulp or something, for prod.
   - Or just use your own setup file.

Handling server termination gracefully? (with Ctrl+C and/or process TERM/KILL/etc signaling)
 - Perhaps it should indicate at least that the application/process was terminated?

Formalize the documentation.
 - Including some JSCause dev documentation (how to contribute, how to add new dependencies to JSCVendor, etc.)

Publish 0.7.0a version here.
 - Indicate what dependencies you're using (per MIT's license?).
   - jscvendor folder.

Syntax highlighters for Atom, VS Code, Vim, Sublime, Notepad++, TextWrangler.
 - Perhaps for future version.
   - Or outsource?

Make two versions:  Standalone and NPM-installable.

Does this work on Windows?

Remove these from /etc/hosts:
127.0.0.1       jscausesite1
127.0.0.1       jscausesite2

Version 0.7.1b here!
 - Upload to https://github.com/eighthjouster/jscause
 - Thanks to:
   - https://github.com/felixge/node-formidable   
   - https://github.com/parshap/node-sanitize-filename
   - https://github.com/pillarjs/cookies

 - Create a couple of sites with it.
 - Announce.
 
==========================

Order by priority:

rt.exit()? No waiting for setTimeouts and the like?
 - Documentation:  If any callback-based operation scheduled, they will still happen but the JSCause won't wait for them. - Dangerous!
   - Doable?  Consider it.  Future version.
   - If you do this, maybe mention it in the redirection documentation (redirect then exit()).

We use jscmFilesList to check that modules compile.  Perhaps we can still use this during runtime as well?  Maybe the 'require' function prototype can be modified so it used the compiled code if available ("compiledCode.call({}, runTime)" just like it's used in responder(), try/catch and all.)
 - Isn't this happening already?

Shouldn't we check if a randomly generated upload file name exists previously before using?

- Optional routing configuration? (configuration/routes.js)

- A configuration flag to indicate whether a file or directory with a name starting with a dot ('.') should be served or not.  Right now, such files are not being served.

- The same file (e.g. through symbolic links) may be compiled/stored as static more than once.  How to optimize this?

- Global settings (per-site defaults.)  Also, indicate if sites can override them in their own files.
  - And if they can't, and they attempt it, warn.

- Resuming interrupted large downloads.

- Server throttling of large static files?

File encoding detection (for now, every file is assumed UTF-8.)
 - Take into account how both the file system and the browser treat special characters.

The values of the constants:
 - MAX_FILES_OR_DIRS_IN_DIRECTORY
 - MAX_DIRECTORIES_TO_PROCESS
 - MAX_PROCESSED_DIRECTORIES_THRESHOLD
 - MAX_CACHED_FILES_PER_SITE
 - MAX_CACHEABLE_FILE_SIZE_BYTES
should be configurable via a config file.

When defining a function and calling it inside a script, 'this' will refer to that of the node environment.  How to avoid this?  Or is this a "feature"? It should be an empty object.

- We have to start writing tests.
  - Define what needs to be tested.
  - Then outsource?

- Create/rename/delete directories?

- Easy way to write binary blobs and text.
  - Follow what rt.readFile() does.

- rt.readFile() alternative that returns a promise?  rt.readFilePromise()?

Decorator for rt.runAfter(() => {});
 - Something like:
    - <js-after begin /> does: <js rt.runAfter(() => { /js>
    - <js-after end /> does: <js }); /js>
    - Both blocks must be _outside_ of <js /js> blocks.

- Retriggable waitFor(), so stuff like on('data') can work. - Otherwise, the app will ignore later calls since the callback was dropped off the queue.
- Cancellable waitFor(), so stuff like retriggable waitFor(), or callbacks that may or may not execute can be cancelled from, say, an on('end') or on('error').
  - Perhaps there could be options, like: waitFor(cb1, { name: 'callback 1', retriggable: true }) and waitFor(cb2, { cancels: 'callback 1' }).

Any way to clean up the upload directory (the one specified in site.json) in case of a server error?
 - Maybe at startup?

 Any way to set fs permissions, so individual website processes can only read/write to their user directories only?

Databases, advanced features.

Uploading files:  When an upload form is submitted with no files specified, the framework still processes such files.  That is, a temp file is created, with size 0, I'm guessing.  And no filenames.
  - Any way to avoid the creation of an unnecessary file?

Plugins.  Something as easy as dropping as a folder in a /plugins folder.

Server-side rendering?
  - For just-HTML-rendering: A way to render in-line before delivering HTML?
    - If you consider the plugin model, this is where you lay the groundwork.
  - For combined API calls: Deliver the state as a one-time payload?
  - As a module/plugin?

JSCause modules.  They are regular npm modules, but certified with no external dependencies.

Better handling of max file size exceeded and uploads forbidden.

If the max file size is reached, the partial uploaded file remains in the system's temp directory.  Deal with this (I tried, I really tried, but just gave up after some time.)

Custom HTTP error pages - 404, 500, 403, etc.

Access to full url.

Set response status code?

Delete header entries?

Clear all header entries?

rt.waitFor():
 - There should be a way to define timeouts, to indicate when the callbacks are taking too long.
   - There should be a default somewhere, maybe 0 for "always wait."
   - If it times out, either throw an error, or run a user's function.

Reload on file change?

Option to crash the server on fatal error?
 - Crash it on immediate compile error.
 - Reload otherwise?

ESLint.

Compile everything? (not just wait for a runtime error to find out that a module has syntax errors.)
 - Don't waste too much time on this.  You can defer it to a future version.

jscp/jscm syntax coloring? linting?

Remove //__RP comments.

====

The framework should do this:
 - Enumerate the folders in sites/
   - Each folder will represent a site.

Implement: GET and POST.
 - Static pages.
Implement: Submit form data.
 - Ajax.
Implement: Talk to a databse.
Implement:
 - https
 - redirections
 - modules/plugins
   - redistributable packages
 - HTTP authentication?
 - How to avoid that the server dies on error?
   - Or at least it should restart itself.
     - Avoid endless loops?

How to hide the nodeJS way to do stuff and simplify as much as possible?

A way to do the "server pre-render" stuff.

Create a test to ensure all the opening/closing/<html/> tag rules according to the specs.

Security.
 - How to avoid, or at least warn or give control to the site, of DDOS by uploading large files or having too many requests?

Docs?

Better rtFileExists() implementation? I dunno, using rtOnError() to signify that the file doesn't exists seems... wrong?

===

Use cases:
 - Regular forms (no uploads).
 - Form uploads.
 - JSON.
   - And security, esp. file size.
 - Databases.
 - Cookies.
 - Redirects.
 - Multi-sites.
 - Server-side rendering (if not too complex.)
 - Other?
